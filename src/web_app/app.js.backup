// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(reg => console.log('Service Worker registered'))
      .catch(err => console.log('SW registration failed:', err));
  });
}

// ========== LEARNING STATISTICS ==========
const LearningStats = {
  // ì„¸ì…˜ í†µê³„
  sessionStart: Date.now(),
  correctStreak: 0,
  maxStreak: 0,
  totalAnswered: 0,
  totalCorrect: 0,

  // LocalStorage í‚¤
  STORAGE_KEY: 'quiz_learning_stats',

  // í†µê³„ ì´ˆê¸°í™”
  init() {
    this.sessionStart = Date.now();
    this.correctStreak = 0;
    this.totalAnswered = 0;
    this.totalCorrect = 0;
    this.loadFromStorage();
  },

  // ?ëº£ë–Ÿ æ¹²ê³•ì¤‰
  recordAnswer(isCorrect) {
    this.totalAnswered++;
    if (isCorrect) {
      this.totalCorrect++;
      this.correctStreak++;
      if (this.correctStreak > this.maxStreak) {
        this.maxStreak = this.correctStreak;
      }
      // 5?ê³—ëƒ½ ?ëº£ë–Ÿ ??ç•°ëº¥ë¸¯ ï§ë¶¿ë–†ï§Â€
      if (this.correctStreak === 5) {
        this.showStreakNotification('?ëµ¦ 5?ê³—ëƒ½ ?ëº£ë–Ÿ!');
      } else if (this.correctStreak === 10) {
        this.showStreakNotification('?ë™š 10?ê³—ëƒ½ ?ëº£ë–Ÿ! ?Â€?â‘¦ë¹??');
      }
    } else {
      this.correctStreak = 0;
    }
    this.saveToStorage();
    this.updateUI();
  },

  // ìŠ¤íŠ¸ë¦­ ì•Œë¦¼
  showStreakNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'streak-notification';
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.classList.add('show'), 10);
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => notification.remove(), 300);
    }, 2000);
  },

  // UI ì—…ë°ì´íŠ¸
  updateUI() {
    const streakEl = document.getElementById('streak-counter');
    if (streakEl) {
      streakEl.textContent = `ğŸ”¥ ${this.correctStreak}`;
      streakEl.style.display = this.correctStreak > 0 ? 'inline-block' : 'none';
    }
  },

  // ?Â€??éºëˆìœ­?ã…ºë¦°
  saveToStorage() {
    const data = {
      maxStreak: this.maxStreak,
      totalAnswered: this.totalAnswered,
      totalCorrect: this.totalCorrect,
      lastSession: Date.now()
    };
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
  },

  loadFromStorage() {
    try {
      const data = JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '{}');
      this.maxStreak = data.maxStreak || 0;
    } catch (e) { }
  },

  // ì •í™•ë„
  getAccuracy() {
    return this.totalAnswered > 0
      ? Math.round((this.totalCorrect / this.totalAnswered) * 100)
      : 0;
  }
};

// ========== API RATE LIMITER ==========
const APIRateLimiter = {
  lastCall: 0,
  minInterval: 500, // ï§¤ì’–ëƒ¼ 0.5ç¥?åª›ê¾§êº½
  queue: [],

  async throttle(fn) {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastCall;

    if (timeSinceLastCall < this.minInterval) {
      await new Promise(r => setTimeout(r, this.minInterval - timeSinceLastCall));
    }

    this.lastCall = Date.now();
    return fn();
  }
};

// ========== ERROR RETRY LOGIC ==========
async function withRetry(fn, maxRetries = 2, delay = 1000) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries) throw err;
      console.warn(`Retry ${i + 1}/${maxRetries}:`, err.message);
      await new Promise(r => setTimeout(r, delay * (i + 1)));
    }
  }
}

// ========== DEBOUNCE UTILITY ==========
function debounce(fn, delay) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

// ========== STUDY TIMER (Pomodoro-style) ==========
const StudyTimer = {
  seconds: 0,
  intervalId: null,
  isRunning: false,

  start() {
    if (this.isRunning) return;
    this.isRunning = true;
    this.intervalId = setInterval(() => {
      this.seconds++;
      this.updateUI();
      // 25ë¶„ë§ˆë‹¤ íœ´ì‹ ì•Œë¦¼
      if (this.seconds === 25 * 60) {
        this.showBreakReminder();
      }
    }, 1000);
  },

  pause() {
    if (!this.isRunning) return;
    this.isRunning = false;
    clearInterval(this.intervalId);
  },

  reset() {
    this.pause();
    this.seconds = 0;
    this.updateUI();
  },

  updateUI() {
    const timerEl = document.getElementById('study-timer');
    if (timerEl) {
      const mins = Math.floor(this.seconds / 60);
      const secs = this.seconds % 60;
      timerEl.textContent = `â±ï¸ ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
  },

  showBreakReminder() {
    if (Notification.permission === 'granted') {
      new Notification('â˜• 25ë¶„ í•™ìŠµ ì™„ë£Œ!', {
        body: '5ë¶„ íœ´ì‹ì„ ê¶Œì¥í•©ë‹ˆë‹¤.',
        icon: '/icon-192.png'
      });
    }
    const reminder = document.createElement('div');
    reminder.className = 'break-reminder';
    reminder.innerHTML = `
      <div class="break-content">
        <span class="break-icon">â˜•</span>
        <strong>25ë¶„ í•™ìŠµ ì™„ë£Œ!</strong>
        <p>ì ì‹œ íœ´ì‹í•˜ê³  ì˜¤ì„¸ìš”!</p>
        <button onclick="this.parentElement.parentElement.remove()">í™•ì¸</button>
      </div>
    `;
    document.body.appendChild(reminder);
    setTimeout(() => reminder.classList.add('show'), 10);
  }
};

// ========== SESSION PROGRESS SAVER ==========
const SessionSaver = {
  STORAGE_KEY: 'quiz_session_progress',

  save() {
    if (!currentSession) return;
    const progress = {
      timestamp: Date.now(),
      session: {
        title: currentSession.title,
        mode: currentSession.mode,
      },
      answers: this.collectAnswers(),
      score: sessionScore?.textContent || '0 / 0'
    };
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(progress));
  },

  collectAnswers() {
    const answers = {};
    document.querySelectorAll('input.blank, textarea.definition-input, textarea.challenge-input, textarea.vocab-input').forEach(el => {
      if (el.dataset.key && el.value) {
        answers[el.dataset.key] = el.value;
      }
    });
    return answers;
  },

  restore() {
    try {
      const saved = JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '{}');
      if (!saved.answers) return;

      // 30éº??ëŒ€ê¶¡???Â€?Î»ì­” è¹‚ë“­ì
      if (Date.now() - saved.timestamp > 30 * 60 * 1000) return;

      Object.entries(saved.answers).forEach(([key, value]) => {
        const el = document.querySelector(`[data-key="${key}"]`);
        if (el && !el.value) el.value = value;
      });
    } catch (e) { }
  },

  clear() {
    localStorage.removeItem(this.STORAGE_KEY);
  }
};

// Auto-save every 30 seconds
setInterval(() => SessionSaver.save(), 30000);

// ========== GLOBAL KEYBOARD SHORTCUTS ==========
const KeyboardShortcuts = {
  enabled: true,

  init() {
    document.addEventListener('keydown', (e) => {
      if (!this.enabled) return;

      // Ctrl+Enter: ?ê¾©ê»œ ï§¢ê¾©ì  (?ë‚…ì ° ä»¥ë¬’ë¿‰???ë¬ë£!)
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        if (typeof checkAll === 'function') checkAll();
        return;
      }

      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        // Escape: ?ë‚…ì ° ?ê¾¨ë±¶ ?ë‰í…§
        if (e.key === 'Escape') {
          e.target.blur();
          return;
        }
        return; // ?ã…»â…¨ ?â‘¥í…?ã…»ë’— ?ë‚…ì ° ä»¥ë¬’ë¿‰??è‡¾ëŒë–†
      }

      // Global shortcuts
      switch (e.key.toLowerCase()) {
        case 'a':
          // A: AI ?â‘¤ê¼¸ ?ì¢‰?
          if (typeof toggleAIPanel === 'function') toggleAIPanel();
          break;
        case 'r':
          // R: ç”±ÑŠë€‘
          if (e.ctrlKey || e.metaKey) return; // Ctrl+R ?ëˆì¤ˆæ€¨ì¢ë¬ ?Â€ ?ë‰ìŠœ
          document.getElementById('btn-reset')?.click();
          break;
        case 's':
          // S: ?ë·€ëµ†
          document.getElementById('btn-shuffle')?.click();
          break;
        case 'k':
          if (e.ctrlKey || e.metaKey) return; // è¹‚ë“­ê¶— ?â‘¥í…?ã…¼? ç•°â‘¸ë£ è«›â‘¹?
          // K: ?ê¾©ê»œ ï§¢ê¾©ì 
          document.getElementById('btn-check')?.click();
          break;
        case 'n':
          // N: ?ã…¼ì“¬ èª˜ëªƒë–Ÿ è‡¾ëª„ì £æ¿¡??ëŒ€ë£
          this.focusNextUnanswered();
          break;
        case '?':
          // ?: ?â‘¥í…???ê¾©?ï§?          this.showHelp();
          break;
        case 'arrowdown':
          e.preventDefault();
          this.navigateQuestion(1);
          break;
        case 'arrowup':
          e.preventDefault();
          this.navigateQuestion(-1);
          break;
      }
    });
  },

  focusNextUnanswered() {
    const inputs = document.querySelectorAll('input.blank:not(.correct):not(.wrong), textarea.definition-input:not(:disabled), textarea.challenge-input:not(:disabled)');
    for (const input of inputs) {
      if (!input.value.trim()) {
        input.scrollIntoView({ behavior: 'smooth', block: 'center' });
        input.focus();
        return;
      }
    }
  },

  navigateQuestion(direction) {
    const cards = document.querySelectorAll('.definition-card, .challenge-card, .vocab-card, .blank-card, .mc-question');
    if (!cards.length) return;

    const currentFocused = document.activeElement?.closest('.definition-card, .challenge-card, .vocab-card, .blank-card, .mc-question');
    let currentIdx = Array.from(cards).indexOf(currentFocused);

    if (currentIdx === -1) currentIdx = direction > 0 ? -1 : cards.length;
    const nextIdx = Math.max(0, Math.min(cards.length - 1, currentIdx + direction));

    const nextCard = cards[nextIdx];
    nextCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
    const input = nextCard.querySelector('input, textarea');
    if (input) input.focus();
  },

  showHelp() {
    const existing = document.querySelector('.shortcuts-modal');
    if (existing) { existing.remove(); return; }

    const modal = document.createElement('div');
    modal.className = 'shortcuts-modal';
    modal.innerHTML = `
      <div class="shortcuts-content">
        <h3>?â‘¨íˆ˜ ?ã…»ë‚«???â‘¥í…??/h3>
        <div class="shortcut-list">
          <div><kbd>N</kbd> ?ã…¼ì“¬ èª˜ëªƒë–Ÿ è‡¾ëª„ì £æ¿¡??ëŒ€ë£</div>
          <div><kbd>??/kbd><kbd>??/kbd> ?ëŒìŸ¾/?ã…¼ì“¬ è‡¾ëª„ì £</div>
          <div><kbd>A</kbd> AI ?â‘¤ê¼¸ ?ì¢‰?</div>
          <div><kbd>S</kbd> ?ì’–ê½Œ ?ìšŠë¦°</div>
          <div><kbd>C</kbd> ?ê¾©ê»œ ï§¢ê¾©ì </div>
          <div><kbd>Ctrl</kbd>+<kbd>Enter</kbd> ?ê¾©ê»œ ï§¢ê¾©ì  (?ë‚…ì ° ä»¥ë¬’ë¿‰??)</div>
          <div><kbd>R</kbd> ç”±ÑŠë€‘</div>
          <div><kbd>Esc</kbd> ?ë‚…ì ° ?ê¾¨ë±¶ ?ë‰í…§</div>
          <div><kbd>?</kbd> ???ê¾©?ï§?/div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()">?ãƒªë¦°</button>
      </div>
    `;
    document.body.appendChild(modal);
    setTimeout(() => modal.classList.add('show'), 10);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }
};

// ========== SOUND EFFECTS (disabled by default) ==========
const SoundEffects = {
  enabled: false,  // æ¹²ê³•ë‚¯åª›? ?ÑŠìŠœ ?ëŠë¸¿

  play(type) {
    if (!this.enabled) return;
    // Simple beep using Web Audio API
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);

      if (type === 'correct') {
        osc.frequency.value = 800;
        gain.gain.value = 0.1;
      } else if (type === 'wrong') {
        osc.frequency.value = 300;
        gain.gain.value = 0.1;
      }

      osc.start();
      osc.stop(ctx.currentTime + 0.1);
    } catch (e) { }
  },

  toggle() {
    this.enabled = !this.enabled;
    localStorage.setItem('sound_effects', this.enabled);
    return this.enabled;
  }
};

// Initialize keyboard shortcuts
KeyboardShortcuts.init();

// ?â‘¥í…??åª›Â€?ëŒ€ë±¶ è¸°ê¾ªë“‰
const btnShortcuts = document.getElementById("btn-shortcuts");
if (btnShortcuts) {
  btnShortcuts.addEventListener("click", () => KeyboardShortcuts.showHelp());
}

// Core UI refs
const codeArea = document.getElementById("code-area");
const sessionTitle = document.getElementById("session-title");
const sessionLang = document.getElementById("session-lang");
const sessionMode = document.getElementById("session-mode");
const sessionCount = document.getElementById("session-count");
const sessionScore = document.getElementById("session-score");
const sessionProgress = document.querySelector("#session-progress span");
const answerBlock = document.getElementById("answer-block");
const blankList = document.getElementById("blank-list");
const reviewBadge = document.getElementById("review-badge");

// AI Panel refs
const aiPanel = document.getElementById("ai-panel");
const explanationArea = document.getElementById("explanation-area");
const chatMessages = document.getElementById("chat-messages");
const chatInput = document.getElementById("chat-input");
const floatingExplain = document.getElementById("floating-explain");
const btnToggleCompleted = document.getElementById("btn-toggle-completed");

let currentSession = null;
let inputs = [];
let answerKeyMap = {};
let reviewQueue = new Set();
let challengeReviewQueue = new Set();
let hasAnswers = false;
let warnedMissingAnswers = false;
let hideCompletedNav = false;

// ?ÑŠìŠœ???ê¾©íŠ‚ ç•°ë¶¿ìŸ» (?ÑŠê¹®????ä»¥ë¬ë‚¬ è«›â‘¹?)
let usedPositions = {}; // { "1": 3, "2": 1 } = ?ê¾©íŠ‚è¹‚??ÑŠìŠœ ?ì›ë‹”

const placeholderRegexFlex = /_{3,10}/g;
const placeholderRegexIndexed = /__\[(\d+)\]__/g;
const modeLabels = {
  1: "1. OOP é®ë‰ë­ ï§¢ê¾©ìŠ¦æ¹²?,
  2: "2. ?ë¨®ì¦ºæ´ÑŠâ€œ é®ë‰ë­",
  3: "3. è«›ê¹†? ?ê³—ë’¿ (Whiteboard)",
  4: "4. ?ã…¼ìŸ¾ ï§â‘¥ì“½æ€¨ì¢ê¶—",
  5: "5. OOP ?ëº¤ì“½ ?ëŒì«°",
  6: "6. è‚„ë¶¾ë±¶ ?ë¬’ê½¦ (?ê¾©ê¶›?ì„‘ë¸°)",
  7: "7. ?ê³·ë–’???ëˆì ´",
};

const missingAnswerMessage = "?ëº£ë–Ÿ ?ã…º? ?ë†ë¼± ï§¢ê¾©ì ?????ë†ë’¿?ëˆë–. ?ëª„ë€¡???ã…¼ë–† ?ì•¹ê½¦??äºŒì‡±ê½­??";
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";
let baseSystemPromptCache = null;

// Initialize learning stats
LearningStats.init();

// ========== API KEY MANAGEMENT ==========
function getApiKey() {
  return (localStorage.getItem("gemini_api_key") || "").trim();
}

function setApiKey(key) {
  localStorage.setItem("gemini_api_key", key);
}

function showApiKeyModal() {
  const modal = document.getElementById("api-key-modal");
  const input = document.getElementById("api-key-input");
  input.value = getApiKey();
  modal.style.display = "flex";
  input.focus();
}

function hideApiKeyModal() {
  document.getElementById("api-key-modal").style.display = "none";
}

// ========== GEMINI API ==========
function scrubSystemPrompt(rawPrompt) {
  if (!rawPrompt) return "";
  const lines = rawPrompt.split(/\r?\n/);
  const filtered = lines.filter(line => {
    const lower = line.toLowerCase();
    const hasHtmlTag = line.includes("<") || lower.includes("html");
    const isCanvasHtml = lower.includes("canvas") && (hasHtmlTag || lower.includes("html"));
    return !(hasHtmlTag || isCanvasHtml);
  });
  return filtered.join("\n").trim();
}

async function loadBaseSystemPrompt() {
  if (baseSystemPromptCache !== null) return baseSystemPromptCache;
  try {
    const resp = await fetch("/data/gemini_system_prompt.txt?t=" + Date.now());
    if (resp.ok) {
      const raw = await resp.text();
      baseSystemPromptCache = scrubSystemPrompt(raw);
      return baseSystemPromptCache;
    }
  } catch (err) {
    console.warn("Failed to load base system prompt", err);
  }
  baseSystemPromptCache = "";
  return baseSystemPromptCache;
}

async function callGeminiAPI(prompt, systemInstruction = "") {
  const apiKey = getApiKey();
  if (!apiKey) {
    showApiKeyModal();
    throw new Error("API ?ã…º? ?ê¾©ìŠ‚?â‘¸ë•²??");
  }

  const basePrompt = await loadBaseSystemPrompt();
  const mergedSystemInstruction = [basePrompt, systemInstruction].filter(Boolean).join("\n\n");

  const body = {
    contents: [{ role: "user", parts: [{ text: prompt }] }],
    generationConfig: {
      temperature: 0.7,
      maxOutputTokens: 2048,
    }
  };

  if (mergedSystemInstruction) {
    body.systemInstruction = { parts: [{ text: mergedSystemInstruction }] };
  }

  const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || "API ?ëª„í…§ ?ã…½ë™£");
  }

  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
}

// ========== AI PANEL ==========
function toggleAIPanel() {
  const isOpen = aiPanel.classList.toggle("open");
  document.body.classList.toggle("panel-open", isOpen);
}

function openAIPanel() {
  aiPanel.classList.add("open");
  document.body.classList.add("panel-open");
}

function closeAIPanel() {
  aiPanel.classList.remove("open");
  document.body.classList.remove("panel-open");
}

// ========== EXPLAIN FEATURE ==========
async function explainBlank(key) {
  const answer = answerKeyMap[key];
  if (!answer) return;

  openAIPanel();

  const lines = (currentSession?.question || "").split("\n");
  const numbered = lines.map((ln, idx) => `${idx + 1}: ${ln}`).join("\n");
  const context = numbered.split("\n").slice(0, 120).join("\n");

  explanationArea.innerHTML = `<div class="explanation-loading">AIåª›Â€ ?ã…»ì±¸???ì•¹ê½¦?ì„í€¬ ?ë‰ë’¿?ëˆë–...</div>`;

  const prompt = `é®ë‰ë­ #${key}???ã…¼ë¼±åª›??ë“­? "${answer}"?? ?ê¾¨ì˜’ è‚„ë¶¾ë±¶ ï§Î»ì”«??è¹‚ë‹¿í€¬ ?ëº£ì­š ï§ãì¾¶ ?ë“­ë––ï§??ëš®ì ®ä»¥?

è‚„ë¶¾ë±¶ ?ì‡°? (??120ä»¥?:
\`\`\`python
${context}
\`\`\`

?ëº¤ë–‡ ?ë‰ë–†:
#3è¸°ë‰ë¿‰ è¸ë¨­? ?ã…¼ë¼±åª›Â€?ì‡³ë¹ ?
-> 3è¸°ë‰ë¿‰??ç”±ÑŠë’ª??é®ê¾©ë¿€?ë¶¿? ï§£ëŒ„ê²•?ëŒê½Œ é®?ç”±ÑŠë’ª?ëªƒãˆƒ "(é®?ç”±ÑŠë’ª??" ç•°ì’•ì °?ì„í€¬ é†«ë‚…ì¦º?ì„ë’— è­°ê³Œêµ”. if start == None:

æ´¹ì’–íŠƒ: ?ì’•ëª¢ ä»¥? è«›ë¶¾ì¤ˆ ?ê³¸ìŠœ?????ëˆë’— ?ëš°ë“ƒï§? ?Î½ì†´???ã…»ì±¸ æ¹²ë‰?.`;

  try {
    const response = await callGeminiAPI(prompt, "ç§»ì’“ë ?ì„í€¬ ï§ãƒ? ?ëš°ë“ƒï§?äºŒì‡°ë’— è‚„ë¶¿íŠ‚ï§£ì„ì†, 1-2ä»¥ê¾¨ì¤ˆ ?ë“­ë––ï§?ï§ë¨°ë¹ä»¥?");
    explanationArea.innerHTML = `
      <div class="explanation-content">
        <strong style="color: var(--accent-2);">é®ë‰ë­ #${key}: <code>${escapeHtml(answer)}</code></strong>
        <hr style="border: none; border-top: 1px solid var(--border); margin: 12px 0;">
        ${formatMarkdown(response)}
      </div>`;
  } catch (err) {
    explanationArea.innerHTML = `<div class="explanation-content" style="color: var(--red);">?ë¨®ìœ­: ${err.message}</div>`;
  }
}

async function explainSelection(text) {
  if (!text.trim()) return;

  openAIPanel();
  explanationArea.innerHTML = `<div class="explanation-loading">AIåª›Â€ ?ã…»ì±¸???ì•¹ê½¦?ì„í€¬ ?ë‰ë’¿?ëˆë–...</div>`;

  const prompt = `?ã…¼ì“¬ Python è‚„ë¶¾ë±¶ è­°ê³Œì»–???Â€???ã…»ì±¸?ëŒï¼œ?ëª„ìŠ‚:

\`\`\`python
${text}
\`\`\`

?ã…¼ì“¬???Ñ‹ë¸¿?ëŒê½Œ ?ã…»ì±¸?ëŒï¼œ?ëª„ìŠ‚:
1. ??è‚„ë¶¾ë±¶åª›Â€ è‡¾ëŒë¾¿???ì„ë’—ï§Â€
2. åª›?éºÂ€éºê¾©ì”  ???ê¾©ìŠ‚?ì’–?
3. ?ëŒ€ë¼¡ ?ê³¹ì†´?ë¨¯ê½Œ ?ÑŠìŠœ?ì„ë’—ï§Â€`;

  try {
    const response = await callGeminiAPI(prompt, "?ë±€ë–Š?Â€ ç§»ì’–ì …???ëš¯ì” ???ê¾¨ì¤ˆæ´¹ëªƒì˜’è«›??ì’—ê½£?ë‚…ë•²?? ç¥ëˆë‚«?ë¨­? ?ëŒ„ë¹?ì„ë¦° ?ì„ì¾¶ ?ã…»ì±¸?ëŒï¼œ?ëª„ìŠ‚.");
    explanationArea.innerHTML = `
      <div class="explanation-content">
        <strong style="color: var(--accent);">?ë®• ?ì¢ê¹®??è‚„ë¶¾ë±¶ ?ã…»ì±¸</strong>
        <pre style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; margin: 8px 0; font-size: 12px; overflow-x: auto;">${escapeHtml(text)}</pre>
        <hr style="border: none; border-top: 1px solid var(--border); margin: 12px 0;">
        ${formatMarkdown(response)}
      </div>`;
  } catch (err) {
    explanationArea.innerHTML = `<div class="explanation-content" style="color: var(--red);">???ã…»ìªŸ: ${err.message}</div>`;
  }
}

// ========== CHAT FEATURE ==========
async function sendChatMessage() {
  const message = chatInput.value.trim();
  if (!message) return;

  // Add user message
  addChatMessage(message, "user");
  chatInput.value = "";

  // Add loading indicator
  const loadingId = Date.now();
  chatMessages.innerHTML += `<div class="chat-message assistant" id="loading-${loadingId}">?ì¨º ?ì•·ì»– ä»¥?..</div>`;
  chatMessages.scrollTop = chatMessages.scrollHeight;

  // Build context with question information
  let context = "";

  // If parsed quiz mode, include question list for AI to understand question numbers
  if (currentSession?.answer_key?._questions && currentQuestions.length > 0) {
    const questionList = currentQuestions.map((q, idx) => {
      const displayIdx = idx + 1;  // ?ê¾©ì˜± ?ì’–ë–† ?ì’–ê½Œ (1, 2, 3...)
      const qId = q.id;            // ?ê¾©ë¿­ æ€¨ì¢ì‘€ ID
      const qType = q.type === "short_answer" ? "?â‘¤ë–Ÿ?? :
        q.type === "fill_blank" ? "é®ë‰ë­" : "åª›ì•·???;
      const codeSnippet = q.code ? `\nè‚„ë¶¾ë±¶: ${q.code.slice(0, 100)}...` : "";
      return `${displayIdx}è¸°?[Q${qId}] ${qType}: ${q.text.slice(0, 80)}${codeSnippet}`;
    }).join("\n");

    context = `?ê¾©ì˜± è‡¾ëª„ì £ ï§â‘¸ì¤‰ (ç¥?${currentQuestions.length}åª›?:
---
${questionList}
---
???ìˆˆê¹®??"Nè¸°?è‡¾ëª„ì £"?ì‡¨í€¬ ?ì„ãˆƒ ??ï§â‘¸ì¤‰?ë¨¯ê½Œ Nè¸°ë‰ë¿‰ ?ëŒ€ë–¦?ì„ë’— è‡¾ëª„ì £?ë‚…ë•²??
??[Q?ãƒ¬ì˜„]???ê¾©ë¿­ æ€¨ì¢ì‘€ ID?ë‚…ë•²??
`;
  } else if (currentSession?.question) {
    context = `?ê¾©ì˜± ?ìˆˆë’¿ ä»¥ë¬’ì”¤ è‚„ë¶¾ë±¶:\n\`\`\`python\n${currentSession.question.slice(0, 2000)}\n\`\`\``;
  }

  // Check if user is asking about a specific question number
  const numMatch = message.match(/(\d+)\s*è¸°?);
  if (numMatch && currentQuestions.length > 0) {
    const qNum = parseInt(numMatch[1]);
    if (qNum >= 1 && qNum <= currentQuestions.length) {
      const targetQ = currentQuestions[qNum - 1];
      context += `\n\n?ë  ${qNum}è¸°?è‡¾ëª„ì £ ?ê³¸ê½­:
- ?ê¾©ë¿­ ID: [Q${targetQ.id}]
- ?ì¢ì‚: ${targetQ.type}
- è‡¾ëª„ì £: ${targetQ.text}
${targetQ.code ? `- è‚„ë¶¾ë±¶:\n\`\`\`python\n${targetQ.code}\n\`\`\`` : ""}
${targetQ.options ? `- ?ì¢?:\n${targetQ.options.map(o => `  ${o.num}. ${o.text}`).join("\n")}` : ""}
${targetQ.correct ? `- ?ëº£ë–Ÿ: ${targetQ.correct}è¸°? : ""}
`;
    }
  }

  const prompt = `${context}\n\n?ìˆˆê¹®??ï§ëˆĞ¦: ${message}`;

  try {
    const response = await callGeminiAPI(prompt, "?ë±€ë–Š?Â€ ç§»ì’–ì …???ê¾¨ì¤ˆæ´¹ëªƒì˜’è«›??ì’—ê½£?ë‚…ë•²?? ?ê¾©ì˜± ?ìˆˆê¹®??åª›ì•·????â‘¤ë–Ÿ??è‡¾ëª„ì £ç‘œ??Â€æ€¨??ë‰ë’¿?ëˆë–. ?ìˆˆê¹®??Nè¸°?è‡¾ëª„ì £?ì‡¨í€¬ ?ì„ãˆƒ ??è‡¾ëª„ì £ ï§â‘¸ì¤‰?ë¨¯ê½Œ ?ëŒ€ë–¦ è¸°ëŠìƒ‡??è‡¾ëª„ì £ç‘œ?ï§¡ì– ë¸˜ ?ã…»ì±¸?ëŒï¼œ?ëª„ìŠ‚. åª›ê¾§ê»?ì„í€¬ ï§ë‚‡ì†—?ì„ì¾¶ ?ë“¬??ëŒï¼œ?ëª„ìŠ‚.");
    document.getElementById(`loading-${loadingId}`).outerHTML =
      `<div class="chat-message assistant">${formatMarkdown(response)}</div>`;
  } catch (err) {
    document.getElementById(`loading-${loadingId}`).outerHTML =
      `<div class="chat-message error">??${err.message}</div>`;
  }
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function addChatMessage(text, role) {
  const div = document.createElement("div");
  div.className = `chat-message ${role}`;
  div.innerHTML = role === "user" ? escapeHtml(text) : formatMarkdown(text);
  chatMessages.appendChild(div);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function formatMarkdown(text) {
  if (!text) return "";
  return text
    .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;overflow-x:auto;font-size:12px;">$2</pre>')
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    .replace(/\n/g, '<br>');
}

// ========== REGENERATE BLANKS ==========
// ?ëŒìŸ¾ é®ë‰ë­ ?ëº£ë–Ÿ???Â€??(ä»¥ë¬ë‚¬ ï§£ëŒ„ê²•??
let previousAnswers = new Set();

async function regenerateBlanks() {
  if (!currentSession?.answer) {
    alert("?ëº£ë–Ÿ è‚„ë¶¾ë±¶åª›Â€ ?ë†ë¼± ??é®ë‰ë­???ì•¹ê½¦?????ë†ë’¿?ëˆë–.");
    return;
  }

  // ï§â‘¤ë–– ?ë¶¿ëƒ¼ ï§¡ì–˜ë¦°
  let modal = document.getElementById("regenerate-modal");

  // ï§â‘¤ë––???ë†ì‘ï§??ìˆˆìŸ»?ì‡°ì¤ˆ ?ì•¹ê½¦ (è«›â‘¹ë¼± è‚„ë¶¾ë±¶)
  if (!modal) {
    const modalHtml = `
      <div id="regenerate-modal" class="modal" style="display:none;">
        <div class="modal-content">
          <h3>?ë´½ ??é®ë‰ë­ ?ì•¹ê½¦</h3>
          <p>?ì•¹ê½¦??é®ë‰ë­??åª›ì’–ë‹”ç‘œ??ë‚…ì °?ì„ê½­??(10~100)</p>
          <input type="number" id="regen-count-input" value="50" min="10" max="100" />
          <div class="modal-actions">
            <button id="btn-confirm-regen">?ì•¹ê½¦?ì„ë¦°</button>
            <button id="btn-cancel-regen">ç—â‘¥ëƒ¼</button>
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML("beforeend", modalHtml);
    modal = document.getElementById("regenerate-modal");
  }

  // ?ëŒ€ê¹½??ç”±ÑŠë’ª???ê³Œê» (ä»¥ë¬ë‚¬ è«›â‘¹? - ??è¸°ëˆì­” ?ê¹…ì¤‰)
  const btnConfirm = document.getElementById("btn-confirm-regen");
  const btnCancel = document.getElementById("btn-cancel-regen");
  const input = document.getElementById("regen-count-input");

  if (btnConfirm && !btnConfirm.dataset.listenerAttached) {
    btnConfirm.dataset.listenerAttached = "true";
    btnConfirm.addEventListener("click", () => {
      const count = parseInt(input.value, 10);
      executeRegenerate(count);
      modal.style.display = "none";
    });
  }

  if (btnCancel && !btnCancel.dataset.listenerAttached) {
    btnCancel.dataset.listenerAttached = "true";
    btnCancel.addEventListener("click", () => {
      modal.style.display = "none";
    });
  }

  // ï§â‘¤ë–– ?ë‹¿ë¦°
  if (modal) {
    modal.style.display = "flex";
    if (input) input.focus();
  }
}

async function executeRegenerate(targetCount) {
  if (isNaN(targetCount) || targetCount < 5) targetCount = 20;
  if (targetCount > 100) targetCount = 100;

  openAIPanel();
  explanationArea.innerHTML = `<div class="explanation-loading">?ëˆì¤ˆ??é®ë‰ë­ ${targetCount}åª›ì’•? ?ì•¹ê½¦?ì„í€¬ ?ë‰ë’¿?ëˆë–...</div>`;

  // ?ê¾©ì˜± ?ëº£ë–Ÿ?ã…¼ì“£ ?ëŒìŸ¾ ?ëº£ë–Ÿ???Â€??  const currentAnswers = new Set(Object.values(answerKeyMap));

  try {
    // æ¿¡ì’–ëº„?ë¨¯ê½Œ é®ë‰ë­ ?ì•¹ê½¦ (APIè¹‚ëŒ€ë– ?ë‰ì ™??
    const result = generateBlanksLocally(currentSession.answer, targetCount, currentAnswers, 5);

    if (result.answerKey && Object.keys(result.answerKey).length > 0) {
      // ?ëŒìŸ¾ ?ëº£ë–Ÿ ?ë‚…ëœ²?ëŒ„ë“ƒ
      previousAnswers = currentAnswers;

      // Update session
      currentSession.question = result.question;
      currentSession.answer_key = result.answerKey;
      answerKeyMap = result.answerKey;

      // Debug logs


      // Re-render
      renderQuestion(result.question, result.answerKey, currentSession.language);

      // Force update session count display
      if (sessionCount) {
        sessionCount.textContent = inputs.length;
      }

      const duplicateCount = result.duplicates;
      explanationArea.innerHTML = `
        <div class="explanation-content">
          <strong style="color: var(--green);">????é®ë‰ë­ ${Object.keys(result.answerKey).length}åª›??ì•¹ê½¦!</strong>
          <p>?ëŒìŸ¾ è‡¾ëª„ì £?Â€ ä»¥ë¬ë‚¬: ${duplicateCount}åª›?/p>
          <p style="color: var(--muted); font-size: 12px;">?ëˆì¤ˆ???ê¾©íŠ‚??é®ë‰ë­???ì•¹ê½¦?ì„ë¿€?ë“¬ë•²??</p>
        </div>`;
    } else {
      throw new Error("é®ë‰ë­ ?ì•¹ê½¦ ?ã…½ë™£");
    }
  } catch (err) {
    console.error("Regenerate error:", err);
    explanationArea.innerHTML = `
      <div class="explanation-content" style="color: var(--red);">
        ??${err.message}
        <p style="color: var(--muted); margin-top: 8px;">?ã…¼ë–† ?ì’•ë£„?ëŒï¼œ?ëª„ìŠ‚.</p>
      </div>`;
  }
}

// ï§â‘¤ë–– ?ëŒ€ê¹½??ç”±ÑŠë’ª???ã…¼ì ™
document.addEventListener("DOMContentLoaded", () => {
  const regenModal = document.getElementById("regenerate-modal");
  const btnConfirmRegen = document.getElementById("btn-confirm-regen");
  const btnCancelRegen = document.getElementById("btn-cancel-regen");
  const regenInput = document.getElementById("regen-count-input");

  if (btnConfirmRegen) {
    btnConfirmRegen.addEventListener("click", () => {
      const count = parseInt(regenInput.value, 10);
      executeRegenerate(count);
      regenModal.style.display = "none";
    });
  }

  if (btnCancelRegen) {
    btnCancelRegen.addEventListener("click", () => {
      regenModal.style.display = "none";
    });
  }
});

/**
 * æ¿¡ì’–ëº„?ë¨¯ê½Œ é®ë‰ë­ ?ì•¹ê½¦ (API ?ë†ì” )
 * @param {string} code - ?ëº£ë–Ÿ è‚„ë¶¾ë±¶
 * @param {number} targetCount - ï§â‘ºëª´ é®ë‰ë­ ?? * @param {Set} previousAnswers - ?ëŒìŸ¾ ?ëº£ë–Ÿ??(ä»¥ë¬ë‚¬ ï§£ëŒ„ê²•??
 * @param {number} maxDuplicates - ï§¤ì’•? ä»¥ë¬ë‚¬ ?ë‰ìŠœ ?? */
function generateBlanksLocally(code, targetCount, previousAnswers, maxDuplicates) {
  const lines = code.split("\n");
  const answerKey = {};
  let blankCount = 0;
  let duplicateCount = 0;

  // ?ëº£ë–Ÿ ?ì¢ìŠš??å¯ƒÂ€???â‘¥ë‹”
  function isValidAnswer(ans) {
    if (!ans || ans.length <= 1) return false;

    // ?ë±€ë‹”æ¹²ê³ ìƒ‡ï§??ë‰ì‘ï§??ì’–ì‡…
    const specialOnly = new Set("()[]{}:,;'\"` ");
    if ([...ans].every(c => specialOnly.has(c))) return false;

    // ?ê³—ìƒ‚?ì’–? æ€¨ë“¬ê°šï§??ë‰ë¼±???ì’–ì‡… (?? ' ', "")
    if (/^['\"]\s*['"]?\)?$/.test(ans)) return false;

    // ?ãƒ¬ì˜„???ëš°ë™†è¸°ë…¹ì”  ï§¤ì’–ëƒ¼ ?ì„êµ¹???ë‰ë¼±????    if (!/[a-zA-Z0-9_]/.test(ans)) return false;

    return true;
  }

  // ?ëº£ë–Ÿ ?ëº£â” ?â‘¥ë‹” (?ê¾ªë»¾ æ„¿ê¾ªìƒ‡/?ì‡³ëª´ ?ì’“êµ…)
  function cleanAnswer(ans) {
    let cleaned = ans.trim();
    while (cleaned.endsWith(')') || cleaned.endsWith(',') || cleaned.endsWith(';')) {
      if (cleaned.endsWith(')')) {
        const openCount = (cleaned.match(/\(/g) || []).length;
        const closeCount = (cleaned.match(/\)/g) || []).length;
        if (closeCount > openCount) {
          cleaned = cleaned.slice(0, -1).trim();
        } else {
          break;
        }
      } else {
        cleaned = cleaned.slice(0, -1).trim();
      }
    }
    return cleaned;
  }

  // é®ë‰ë­ ?ê¾¨ë‚«?ã…¼ì“£ ç™’ì‡±? ?ì„ì­›
  const candidates = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const stripped = line.trim();

    // å«„ëŒ€ê¼«??ä»¥ê¾¨ë±¾
    if (!stripped ||
      stripped.startsWith("def ") ||
      stripped.startsWith("class ") ||
      stripped.startsWith("import ") ||
      stripped.startsWith("from ") ||
      stripped.startsWith("#") ||
      stripped.startsWith('"""') ||
      stripped.startsWith("'''")) {
      continue;
    }

    // ?Â€?ë‚…Ğ¦ ?â‘¦ê½©: = ?ã…¼ì“½ åª›?    const assignMatch = line.match(/=\s*([^#\n=]+)$/);
    if (assignMatch) {
      const rawAns = assignMatch[1].trim();
      const ans = cleanAnswer(rawAns);
      if (isValidAnswer(ans)) {
        candidates.push({
          lineIndex: i,
          answer: ans,
          type: "assign",
          isDuplicate: previousAnswers.has(ans)
        });
      }
    }

    // return è‡¾?    const returnMatch = line.match(/return\s+([^#\n]+)$/);
    if (returnMatch) {
      const rawAns = returnMatch[1].trim();
      const ans = cleanAnswer(rawAns);
      if (isValidAnswer(ans)) {
        candidates.push({
          lineIndex: i,
          answer: ans,
          type: "return",
          isDuplicate: previousAnswers.has(ans)
        });
      }
    }

    // while è­°ê³Œêµ”
    const whileMatch = line.match(/while\s+([^:]+):/);
    if (whileMatch) {
      const ans = whileMatch[1].trim();
      if (isValidAnswer(ans)) {
        candidates.push({
          lineIndex: i,
          answer: ans,
          type: "while",
          isDuplicate: previousAnswers.has(ans)
        });
      }
    }

    // if è­°ê³Œêµ”
    const ifMatch = line.match(/if\s+([^:]+):/);
    if (ifMatch) {
      const ans = ifMatch[1].trim();
      if (isValidAnswer(ans)) {
        candidates.push({
          lineIndex: i,
          answer: ans,
          type: "if",
          isDuplicate: previousAnswers.has(ans)
        });
      }
    }
  }

  // ä»¥ë¬ë‚¬???ê¾¨ë•¶ å¯ƒê»Šë±¾ ç™’ì‡±?, æ´¹??ã…¼ì“¬ ä»¥ë¬ë‚¬ (ï§¤ì’•? maxDuplicatesåª›?
  const nonDuplicates = candidates.filter(c => !c.isDuplicate);
  const duplicates = candidates.filter(c => c.isDuplicate);

  // ?ë·€ëµ† ?â‘¥ë‹”
  const shuffle = arr => arr.sort(() => Math.random() - 0.5);

  // é®ê¾©ì¨·è¹‚??ìšŠë¦°
  shuffle(nonDuplicates);
  shuffle(duplicates);

  // ?ì¢ê¹®???ê¾¨ë‚«??  const selected = [];
  const usedLines = new Set();

  // é®ê¾©ì¨·è¹‚?ç™’ì‡±? ç•°ë¶½?
  for (const c of nonDuplicates) {
    if (selected.length >= targetCount) break;
    if (usedLines.has(c.lineIndex)) continue; // ??ä»¥ê¾©ë¿‰ ?ì„êµ¹ï§?    selected.push(c);
    usedLines.add(c.lineIndex);
  }

  // éºÂ€è­°ê¹Šë¸¯ï§?ä»¥ë¬ë‚¬?ë¨¯ê½Œ ç•°ë¶½? (ï§¤ì’•? maxDuplicatesåª›?
  let addedDuplicates = 0;
  for (const c of duplicates) {
    if (selected.length >= targetCount) break;
    if (addedDuplicates >= maxDuplicates) break;
    if (usedLines.has(c.lineIndex)) continue;
    selected.push(c);
    usedLines.add(c.lineIndex);
    addedDuplicates++;
  }

  // ?ì‡±ì”¤ ?ì’–ê½Œ?Â€æ¿¡??ëº£ì ¹
  selected.sort((a, b) => a.lineIndex - b.lineIndex);

  // é®ë‰ë­ ?ê³¸ìŠœ - __[N]__ ?ëº¤ë–‡?ì‡°ì¤ˆ ?ì•¹ê½¦ (?ëªƒëœ³?ã…½ì‚ é®ë‰ë­)
  const newLines = [...lines];
  for (const item of selected) {
    blankCount++;
    const key = String(blankCount);
    answerKey[key] = item.answer;
    if (item.isDuplicate) duplicateCount++;

    // ?ëŒ€ë–¦ ä»¥ê¾©ë¿‰??åª›ë¯ªì“£ __[N]__æ¿¡?ç§»ì„‘ì†š (?ëªƒëœ³?ã…½ì‚ é®ë‰ë­)
    const line = newLines[item.lineIndex];
    const escaped = item.answer.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const blankMarker = `__[${key}]__`;
    newLines[item.lineIndex] = line.replace(new RegExp(escaped), blankMarker);
  }

  return {
    question: newLines.join("\n"),
    answerKey: answerKey,
    duplicates: duplicateCount
  };
}

// ========== TEXT SELECTION FOR EXPLAIN ==========
let lastSelection = "";

document.addEventListener("mouseup", (e) => {
  const selection = window.getSelection();
  const text = selection.toString().trim();

  if (text && text.length > 3 && codeArea.contains(selection.anchorNode)) {
    lastSelection = text;
    const rect = selection.getRangeAt(0).getBoundingClientRect();
    floatingExplain.style.left = `${rect.left + window.scrollX}px`;
    floatingExplain.style.top = `${rect.bottom + window.scrollY + 5}px`;
    floatingExplain.style.display = "block";
  } else if (!floatingExplain.contains(e.target)) {
    floatingExplain.style.display = "none";
  }
});

document.addEventListener("mousedown", (e) => {
  if (!floatingExplain.contains(e.target)) {
    floatingExplain.style.display = "none";
  }
});

// ========== EVENT LISTENERS (Initialization) ==========
// These run immediately - essential for file loading

// File upload button
const btnUpload = document.getElementById("btn-upload");
if (btnUpload) {
  btnUpload.addEventListener("click", () => {
    document.getElementById("file-input").click();
  });
}

const fileInput = document.getElementById("file-input");
if (fileInput) {
  fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const data = JSON.parse(evt.target.result);
        setSession(data);
      } catch (err) {
        alert("JSON ?ëš¯ë–› ?ã…½ë™£: " + err.message);
      }
    };
    reader.readAsText(file, "utf-8");
  });
}

// Control buttons - with null checks for safety
const btnCheck = document.getElementById("btn-check");
if (btnCheck) btnCheck.addEventListener("click", () => checkAll());

const btnReveal = document.getElementById("btn-reveal");
if (btnReveal) btnReveal.addEventListener("click", () => revealAll());

const btnReset = document.getElementById("btn-reset");
if (btnReset) btnReset.addEventListener("click", () => resetInputs());

const btnReview = document.getElementById("btn-review");
if (btnReview) btnReview.addEventListener("click", () => startReviewCycle());

if (btnToggleCompleted) {
  btnToggleCompleted.addEventListener("click", () => {
    hideCompletedNav = !hideCompletedNav;
    btnToggleCompleted.textContent = hideCompletedNav ? "?ê¾¨ì¦º è¹‚ëŒì” æ¹²? : "?ê¾¨ì¦º ?â‘£ë¦°æ¹²?;
    applyNavFilter();
  });
}

const btnRegenerate = document.getElementById("btn-regenerate");
if (btnRegenerate) btnRegenerate.addEventListener("click", () => regenerateBlanks());

const btnShuffle = document.getElementById("btn-shuffle");
if (btnShuffle) btnShuffle.addEventListener("click", () => toggleShuffle());

// ï§â‘¤ë±¶è¹‚ê¾¨ì¤ˆ ?ëª„í…§??è€Œâ‘¦ë“ƒæ¿¡?è¸°ê¾ªë“‰ ï§ã…½ë¸¨
const controlButtonsByMode = {
  1: ["btn-check", "btn-reveal", "btn-reset", "btn-review", "btn-toggle-completed", "btn-regenerate", "btn-shuffle"],
  2: ["btn-check", "btn-reveal", "btn-reset", "btn-review", "btn-toggle-completed", "btn-regenerate", "btn-shuffle"],
  3: ["btn-check", "btn-reveal", "btn-reset", "btn-review", "btn-toggle-completed"],
  4: ["btn-shuffle"],
  5: ["btn-check", "btn-reset", "btn-review", "btn-shuffle"],
  6: [],
  7: ["btn-check", "btn-reset", "btn-shuffle"],
};

function updateControlButtonsForMode(mode) {
  const controlIds = [
    "btn-check",
    "btn-reveal",
    "btn-reset",
    "btn-review",
    "btn-toggle-completed",
    "btn-regenerate",
    "btn-shuffle",
  ];
  const allowed = new Set(controlButtonsByMode[mode] || controlIds);
  controlIds.forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = allowed.has(id) ? "" : "none";
  });
}

const btnScrollTop = document.getElementById("btn-scroll-top");
if (btnScrollTop) {
  btnScrollTop.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
}

// API Key modal - with null checks
const btnApiKey = document.getElementById("btn-api-key");
if (btnApiKey) btnApiKey.addEventListener("click", showApiKeyModal);

const btnShutdown = document.getElementById("btn-shutdown");
if (btnShutdown) {
  btnShutdown.addEventListener("click", async () => {
    if (!confirm("?ì’•ì¾­ç‘œ?é†«ë‚…ì¦º?ì¢‰í‰´?? (é‡‰ëš®ì”ª?ê³—?ï§??ãƒ¬ë¸˜???ì’•ì¾­??æ€¨ê¾©ëƒ½ ?ã…½ë»¾?â‘¸ë•²??")) return;
    btnShutdown.disabled = true;
    btnShutdown.textContent = "é†«ë‚…ì¦º ?ë¶¿ê»Œ...";
    try {
      await fetch("/shutdown", { method: "POST" });
      btnShutdown.textContent = "?ì’•ì¾­ é†«ë‚…ì¦º??;
    } catch (e) {
      alert("?ì’•ì¾­ é†«ë‚…ì¦º ?ë¶¿ê»Œ ?ã…½ë™£: " + e.message);
      btnShutdown.disabled = false;
      btnShutdown.textContent = "???ì’•ì¾­ é†«ë‚…ì¦º";
    }
  });
}

const btnSaveApiKey = document.getElementById("btn-save-api-key");
if (btnSaveApiKey) {
  btnSaveApiKey.addEventListener("click", async () => {
    const key = document.getElementById("api-key-input").value.trim();
    if (key) {
      // æ¿¡ì’–ëº„ ?Â€??      setApiKey(key);

      // ?ì’•ì¾­???ê³´ë„ ?Â€??(???ëš¯ì”ª??æ¹²ê³•ì¤‰)
      try {
        const response = await fetch('/api/save-key', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ api_key: key })
        });
        const result = await response.json();
        if (result.success) {
          alert('??API ?ã…º? ?ì’•ì¾­???Â€?Î»ë¦º?ë‰ë’¿?ëˆë–.\n?ã…¼ì“¬ ?ã…½ë»¾?ë¨¯ê½Œ???ë¨®ë£ ?ê³¸ìŠœ?â‘¸ë•²??');
        } else {
          console.warn('?ì’•ì¾­ ?Â€???ã…½ë™£:', result.error);
        }
      } catch (err) {
        console.warn('?ì’•ì¾­ ?Â€???ã…»ìªŸ:', err);
      }

      hideApiKeyModal();
    }
  });
}

const btnCancelApiKey = document.getElementById("btn-cancel-api-key");
if (btnCancelApiKey) btnCancelApiKey.addEventListener("click", hideApiKeyModal);

// ï§â‘¤ì»®??AI ?ì¢‰? è¸°ê¾ªë“‰
const aiToggleBtn = document.getElementById("btn-ai-toggle");
if (aiToggleBtn) {
  aiToggleBtn.addEventListener("click", () => {
    toggleAIPanel();
    aiToggleBtn.classList.toggle("panel-open", aiPanel.classList.contains("open"));
  });
}

// Scroll button visibility
window.addEventListener("scroll", () => {
  const btn = document.getElementById("btn-scroll-top");
  if (!btn) return;
  if (window.scrollY > 120) btn.classList.add("show");
  else btn.classList.remove("show");
});

// AI Panel close button - with null check
const btnClosePanel = document.getElementById("btn-close-panel");
if (btnClosePanel) btnClosePanel.addEventListener("click", closeAIPanel);

// Ctrl+L keyboard shortcut for AI panel
document.addEventListener("keydown", (e) => {
  if (e.ctrlKey && e.key.toLowerCase() === "l") {
    e.preventDefault();
    toggleAIPanel();
  }
});

// Chat input - with null checks
const btnSendChat = document.getElementById("btn-send-chat");
if (btnSendChat) btnSendChat.addEventListener("click", sendChatMessage);

if (chatInput) {
  chatInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendChatMessage();
    }
  });
}

// Floating explain button - with null check
const btnExplainSelection = document.getElementById("btn-explain-selection");
if (btnExplainSelection) {
  btnExplainSelection.addEventListener("click", () => {
    floatingExplain.style.display = "none";
    explainSelection(lastSelection);
  });
}

// ========== UTILITY FUNCTIONS ==========
function escapeHtml(str) {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function pickFirstCodeBlock(text) {
  if (!text) return "";
  const match = text.match(/```(?:\w+)?\s*([\s\S]*?)```/);
  if (match) return match[1].trim();
  return text.trim();
}

function flattenAnswerKey(rawKey) {
  if (!rawKey || typeof rawKey !== "object") return {};
  if ("answer_key" in rawKey && typeof rawKey.answer_key === "object") {
    rawKey = rawKey.answer_key;
  }
  const normalized = {};
  Object.entries(rawKey).forEach(([k, v]) => {
    // ?ãƒ¬ì˜„ ???ë¨®ë’— _æ¿¡??ì’–ì˜‰?ì„ë’— ?ë±€ë‹” ???ì¢?
    if (/^\d+$/.test(k) || k.startsWith("_")) {
      normalized[String(k)] = v;
    }
  });
  return normalized;
}

function extractAnswerKeyFromMarkdown(text) {
  if (!text) return {};
  const jsonBlocks = text.match(/```json\s*([\s\S]*?)\s*```/g) || [];
  for (const block of jsonBlocks) {
    const jsonContent = block.replace(/```json\s*/g, '').replace(/\s*```/g, '');
    try {
      const parsed = JSON.parse(jsonContent);
      const keys = Object.keys(parsed);
      if (keys.length > 0 && keys.every(k => /^\d+$/.test(k) || k === "answer_key")) {
        if (parsed.answer_key) {
          return flattenAnswerKey(parsed.answer_key);
        }
        return flattenAnswerKey(parsed);
      }
    } catch (e) {
      continue;
    }
  }
  return {};
}

function deriveAnswerKeyFromAnswer(question, answer) {
  if (!question || !answer || answer.includes("Parsing failed")) return {};
  const keys = [];
  let seqCounter = 0;
  const escapeForRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const patternParts = [];
  let lastIndex = 0;
  const regex = /__\[(\d+)\]__|_{3,10}/g;
  let match;
  while ((match = regex.exec(question)) !== null) {
    const [fullMatch, idx] = match;
    patternParts.push(escapeForRegex(question.slice(lastIndex, match.index)));
    if (idx !== undefined) {
      keys.push(String(idx));
    } else {
      seqCounter += 1;
      keys.push(String(seqCounter));
    }
    patternParts.push("(.+?)");
    lastIndex = regex.lastIndex;
  }
  patternParts.push(escapeForRegex(question.slice(lastIndex)));
  const pattern = "^" + patternParts.join("") + "$";
  try {
    const compiled = new RegExp(pattern, "s");
    const found = answer.match(compiled);
    if (!found) return {};
    const derived = {};
    keys.forEach((key, i) => {
      if (!(key in derived)) {
        derived[key] = (found[i + 1] || "").trim();
      }
    });
    return derived;
  } catch (e) {
    return {};
  }
}

function countPlaceholders(questionText) {
  if (!questionText) return 0;
  placeholderRegexFlex.lastIndex = 0;
  placeholderRegexIndexed.lastIndex = 0;
  const seqCount = (questionText.match(placeholderRegexFlex) || []).length;
  const idxCount = (questionText.match(placeholderRegexIndexed) || []).length;
  return seqCount + idxCount;
}

function reconstructAnswer(question, answerKey) {
  if (!question || !answerKey || Object.keys(answerKey).length === 0) return "";
  let counter = 0;
  let reconstructed = question.replace(/__\[(\d+)\]__|_{3,10}/g, (match, idx) => {
    let key;
    if (idx !== undefined) {
      key = String(idx);
    } else {
      counter += 1;
      key = String(counter);
    }
    return answerKey[key] !== undefined ? answerKey[key] : match;
  });
  return reconstructed;
}

function normalizeSession(session) {
  let questionRaw = session.question ?? session.question_text ?? session.questionText ?? "";
  const questionCode = pickFirstCodeBlock(questionRaw);
  let answerRaw = session.answer ?? session.answer_text ?? session.answerText ?? "";
  let answerKey = flattenAnswerKey(session.answer_key || session.answerKey || {});

  if (Object.keys(answerKey).length === 0) {
    const extracted = extractAnswerKeyFromMarkdown(session.question_text || session.questionText || "");
    if (Object.keys(extracted).length > 0) {
      answerKey = extracted;
    }
  }

  let answerCode = pickFirstCodeBlock(answerRaw);
  if (!answerCode || answerCode.includes("Parsing failed")) {
    if (questionCode && Object.keys(answerKey).length > 0) {
      answerCode = reconstructAnswer(questionCode, answerKey);
    }
  }

  if (Object.keys(answerKey).length === 0 && answerCode && !answerCode.includes("Parsing failed")) {
    const derived = deriveAnswerKeyFromAnswer(questionCode, answerCode);
    if (Object.keys(derived).length > 0) {
      answerKey = derived;
    }
  }

  placeholderRegexIndexed.lastIndex = 0;
  placeholderRegexFlex.lastIndex = 0;

  return {
    title: session.title || "?ì’•ã‰ ?ë†ì“¬",
    language: session.language === "text" ? "python" : (session.language || "python"),
    mode: session.mode || "-",
    question: questionCode,
    answer: answerCode,
    answer_key: answerKey,
  };
}

function loadSessionFromUrl(url, fallback = true) {
  fetch(url + "?t=" + Date.now())
    .then((r) => {
      if (!r.ok) throw new Error("?ëª„ë€¡??éºëˆìœ­?ã…¼? ï§ì‚µë»½?ë“¬ë•²??");
      return r.json();
    })
    .then((data) => setSession(data))
    .catch((err) => {
      console.warn(err.message);
      if (fallback && url !== "sample_session.json") {
        loadSessionFromUrl("sample_session.json", false);
      } else {
        alert(err.message);
      }
    });
}

// === Mode 2 ?ëªƒì”ª??é®ë‰ë­ è¹‚Â€??===
function buildInlineBlankCode(originalCode, blanks, answerKey) {
  /**
   * ?ë¨®ë‚¯ è‚„ë¶¾ë±¶?Â€ é®ë‰ë­ ?ëº£ë‚«ç‘œ?è«›ì†ë¸˜??__[N]__ ?ëº¤ë–‡???ëªƒì”ª??é®ë‰ë­ è‚„ë¶¾ë±¶æ¿¡?è¹‚Â€??   * blanks: [{line_num, answer, full_line, context}, ...]
   */
  const lines = originalCode.split('\n');

  const blanksByLine = {};

  // ?ì‡±ì”¤è¹‚ê¾¨ì¤ˆ é®ë‰ë­ æ´¹ëªƒï¼™??  blanks.forEach((blank, idx) => {
    const lineNum = blank.line_num;  // 1-indexed
    if (!blanksByLine[lineNum]) {
      blanksByLine[lineNum] = [];
    }
    blanksByLine[lineNum].push({
      blankNum: idx + 1,
      answer: blank.answer
    });
  });



  let replacedCount = 0;
  let failedCount = 0;

  // åª›??ì‡±ì”¤ ï§£ì„â”
  const resultLines = lines.map((line, idx) => {
    const lineNum = idx + 1;  // 1-indexed
    if (!blanksByLine[lineNum]) return line;

    let modifiedLine = line;
    const blanksForLine = blanksByLine[lineNum];

    // ?ëŒ€ë–¦ ?ì‡±ì”¤??ï§â‘¤ë±º é®ë‰ë­ ï§£ì„â” (??ë‹š?ì‡°ì¤ˆ ï§£ì„â”?ëŒê½Œ ?ëªƒëœ³??ç‘—ÑŠì—« è«›â‘¹?)
    blanksForLine.sort((a, b) => b.blankNum - a.blankNum);

    for (const blank of blanksForLine) {
      const answer = blank.answer;
      const blankMarker = `__[${blank.blankNum}]__`;

      // ?ëº£ë–Ÿ ?ê¾©íŠ‚ ï§¡ì– ë¸˜??é®ë‰ë­?ì‡°ì¤ˆ æ´ë¨¯ê»œ
      const answerIndex = modifiedLine.indexOf(answer);
      if (answerIndex !== -1) {
        modifiedLine = modifiedLine.slice(0, answerIndex) + blankMarker + modifiedLine.slice(answerIndex + answer.length);
        replacedCount++;
      } else {
        // ?ëº£ë–Ÿ??ï§¡ì– ? ï§ì‚µë¸³ å¯ƒìŒìŠ¦, ?ì‡±ì”¤ ?ì•¹ë¿‰ ï§ë‰ë¹± ç•°ë¶½? (fallback)
        console.warn(`[Blank ${blank.blankNum}] Answer not found in line ${lineNum}: "${answer}" in "${line}"`);
        failedCount++;
      }
    }

    return modifiedLine;
  });



  return resultLines.join('\n');
}

// === Mode 3 ?ëªƒì”ª??é®ë‰ë­ è¹‚Â€??(?â‘¥ë‹” è¹‚ëªƒĞ¦??é®ë‰ë­?ì‡°ì¤ˆ) ===
function buildInlineChallengeCode(originalCode, challenges, answerKey) {
  /**
   * ?ë¨®ë‚¯ è‚„ë¶¾ë±¶?Â€ ï§¢ëš®â”›ï§Â€ ?ëº£ë‚«ç‘œ?è«›ì†ë¸˜???â‘¥ë‹” è¹‚ëªƒĞ¦??__[N]__ ?ëº¤ë–‡?ì‡°ì¤ˆ è¹‚Â€??   * challenges: [{signature, body, line_num}, ...]
   */
  const lines = originalCode.split('\n');
  let challengeNum = 0;
  let resultLines = [...lines];

  // åª›?ï§¢ëš®â”›ï§Â€(?â‘¥ë‹”)è¹‚ê¾¨ì¤ˆ ï§£ì„â”
  challenges.forEach((ch, idx) => {
    challengeNum = idx + 1;
    const signature = ch.signature;
    const body = ch.body;

    // ?ì’“ë ‡?ë‰ì¿‚ ?ì‡±ì”¤ ï§¡ì–˜ë¦°
    let sigLineIdx = -1;
    for (let i = 0; i < resultLines.length; i++) {
      if (resultLines[i].trim().startsWith(signature.trim().split('(')[0])) {
        sigLineIdx = i;
        break;
      }
    }

    if (sigLineIdx !== -1) {
      // ?â‘¥ë‹” è¹‚ëªƒĞ¦ ?ì‡±ì”¤?ã…¼ì“£ é®ë‰ë­?ì‡°ì¤ˆ æ´ë¨¯ê»œ
      const bodyLines = body.split('\n').filter(l => l.trim());
      if (bodyLines.length > 0) {
        // ï§£?è¸°ë‰ã è¹‚ëªƒĞ¦ ?ì‡±ì”¤ ?ëªƒëœ³??ï§¡ì–˜ë¦° (?ì’“ë ‡?ë‰ì¿‚ ?ã…¼ì“¬ ?ì‡±ì”¤??
        let bodyStartIdx = sigLineIdx + 1;
        let bodyEndIdx = bodyStartIdx;

        // è¹‚ëªƒĞ¦ ??ï§¡ì–˜ë¦° (?ã…¼ë¿¬?ê³Œë¦° æ¹²ê³—?)
        const sigIndent = resultLines[sigLineIdx].match(/^(\s*)/)[1].length;
        for (let i = bodyStartIdx; i < resultLines.length; i++) {
          const line = resultLines[i];
          const lineIndent = line.match(/^(\s*)/)?.[1]?.length || 0;
          if (line.trim() && lineIndent <= sigIndent && !line.trim().startsWith('#')) {
            bodyEndIdx = i;
            break;
          }
          bodyEndIdx = i + 1;
        }

        // è¹‚ëªƒĞ¦ ?ì‡±ì”¤?ã…¼ì“£ é®ë‰ë­?ì‡°ì¤ˆ æ´ë¨¯ê»œ
        const indent = resultLines[sigLineIdx + 1]?.match(/^(\s*)/)?.[1] || '    ';
        const blankPlaceholder = `${indent}# __[${challengeNum}]__ ???â‘¥ë‹”??æ´Ñ‹ì½éºÂ€ç‘œ??ë¬’ê½¦?ì„ê½­??;

        // ?ë¨®ì˜’ ?ì‡±ì”¤?ã…¼ì“£ äºŒì‡±ê½ ï§£ì„â”?ì„êµ…??é®ë‰ë­?ì‡°ì¤ˆ æ´ë¨¯ê»œ
        for (let i = bodyStartIdx; i < bodyEndIdx && i < resultLines.length; i++) {
          const line = resultLines[i];
          if (line.trim() && !line.trim().startsWith('#') && !line.trim().startsWith('"""') && !line.trim().startsWith("'''")) {
            resultLines[i] = indent + `__[${challengeNum}]__  # ${line.trim()}`;
            // ï§£?ä»¥ê¾¨ì­” é®ë‰ë­?ì‡°ì¤ˆ, ?ì„ã‰§ï§Â€???â‘£?
            if (i > bodyStartIdx) {
              resultLines[i] = '';  // ?ì„ã‰§ï§Â€ ?ì‡±ì”¤ ?ì’“êµ…
            }
          }
        }
      }
    }
  });

  // é®??ì‡±ì”¤ ?ëº£â”
  resultLines = resultLines.filter((line, idx, arr) => {
    // ?ê³—ëƒ½ é®??ì‡±ì”¤ ?ì’“êµ…
    if (line === '' && arr[idx - 1] === '') return false;
    return true;
  });

  return resultLines.join('\n');
}


function setSession(rawSession) {
  // rawSession.answer_key?ë¨¯ê½Œ ?ë±€ë‹” ?ê¾¨ë±¶?ã…¼ì“£ ç™’ì‡±? ç•°ë¶¿í…§ (normalizeSession ?ê¾©ë¿‰)
  const rawAnswerKey = rawSession.answer_key || rawSession.answerKey || {};
  const rawBlanks = rawAnswerKey._blanks;
  const rawOriginalCode = rawAnswerKey._original_code;
  const rawChallenges = rawAnswerKey._challenges;

  currentSession = normalizeSession(rawSession);
  const { title, language, mode, question, answer, answer_key } = currentSession;
  challengeReviewQueue = new Set();

  // ?ë±€ë‹” ?ê¾¨ë±¶?ã…¼ì“£ answer_key??è¹‚ë“­ì (normalizeSession?ë¨¯ê½Œ ?ë¨¯ë–?ì„ë¿€?????ë‰ì“¬)
  if (rawBlanks && !answer_key._blanks) {
    answer_key._blanks = rawBlanks;
  }
  if (rawOriginalCode && !answer_key._original_code) {
    answer_key._original_code = rawOriginalCode;
  }
  if (rawChallenges && !answer_key._challenges) {
    answer_key._challenges = rawChallenges;
  }

  warnedMissingAnswers = false;
  usedPositions = {}; // Reset used positions for new session

  sessionTitle.textContent = title || "?ì’•ã‰ ?ë†ì“¬";
  sessionLang.textContent = language || "python";
  sessionMode.textContent = modeLabels[mode] || mode || "-";
  updateControlButtonsForMode(mode);
  answerBlock.textContent = answer || "(?ëº£ë–Ÿ/?ëŒê½•???ë†ë’¿?ëˆë–)";
  highlightAnswer(language);

  answerKeyMap = answer_key || {};

  // ï§â‘¤ë±¶è¹‚??ëš®ëœ‘ï§?  const type = answer_key?._type;

  if (type === "parsed_quiz" && answer_key?._questions) {
    renderParsedQuiz(answer_key._questions, answer_key, language);
  } else if (type === "multiple_choice" && answer_key?._questions) {
    renderMultipleChoiceNew(answer_key._questions, answer_key, language);
  } else if ((type === "fill_in_blank_cards" || type === "fill_in_blank_inline") && answer_key?._blanks) {
    // Mode 2: ?ê¾©ê»œ è‚„ë¶¾ë±¶???ëªƒì”ª??é®ë‰ë­ ?ëº¥ê¹­æ¿¡??ëš®ëœ‘ï§?    // Python?ë¨¯ê½Œ question???ëªƒì”ª??é®ë‰ë­ è‚„ë¶¾ë±¶ç‘œ?ï§ê³¸ì ’ ?ì•¹ê½¦??    // question???ëŒ€? ?ëªƒì”ª??é®ë‰ë­ ?ëº¤ë–‡?ëª„? ?ëº¤ì”¤ (__[N]__ ?â‘¦ê½© ?Ñ‹ë¸¿)
    const hasInlineBlanks = /__\[\d+\]__/.test(question);

    if (hasInlineBlanks && question.length > 50) {
      // Python è«›ê¹†ë¿?ì’–ë¿‰???ì•¹ê½¦???ëªƒì”ª??é®ë‰ë­ è‚„ë¶¾ë±¶ç‘œ?ï§ê³¸ì ’ ?ÑŠìŠœ

      renderQuestion(question, answer_key, language);
    } else {
      // ?ëŒ€ê°š: JS?ë¨¯ê½Œ ?ëªƒì”ª??é®ë‰ë­ é®ëš®ë±¶ ?ì’•ë£„
      const originalCode = answer_key._original_code || currentSession.answer || "";
      if (originalCode && originalCode.length > 50) {
        const inlineCode = buildInlineBlankCode(originalCode, answer_key._blanks, answer_key);
        renderQuestion(inlineCode, answer_key, language);
      } else {

        renderQuestion(question || "", answer_key, language);
      }
    }
  } else if (type === "implementation_challenge" && answer_key?._challenges) {
    // Mode 3: ??ê¸½ ç§»ëŒ€ë±¶ ?ëº¥ê¹­æ¿¡??ëš®ëœ‘ï§?(è‚„ë¶¾ë±¶ ?ë¨®ëµ’??+ AI ï§¢ê¾©ì )
    renderImplementationChallenge(answer_key._challenges, answer_key, language);
  } else if (type === "definition_quiz" && answer_key?._definitions) {
    renderDefinitionQuiz(answer_key._definitions, answer_key, language);
  } else if (type === "vocabulary_cards" && answer_key?._words) {
    renderVocabularyCards(answer_key._words, answer_key, language);
  } else {

    renderQuestion(question || "", answer_key || {}, language);
  }
}

function renderQuestion(questionText, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  answerKeyMap = answerKey;

  const hasIndexed = placeholderRegexIndexed.test(questionText);
  placeholderRegexIndexed.lastIndex = 0;
  placeholderRegexFlex.lastIndex = 0;

  const lines = questionText.split("\n");
  const frag = document.createDocumentFragment();
  let counter = 0;

  lines.forEach((line, lineIdx) => {
    const lineElem = document.createElement("div");
    lineElem.className = "code-line";
    const lineNo = document.createElement("div");
    lineNo.className = "line-no";
    lineNo.textContent = lineIdx + 1;
    const codeText = document.createElement("div");
    codeText.className = "code-text";

    let lineHtml = line;
    let lineKeys = [];

    if (hasIndexed) {
      lineHtml = lineHtml.replace(/__\[(\d+)\]__/g, (_, idx) => {
        lineKeys.push(idx);
        return `__BLANK_MARKER_${idx}__`;
      });
    } else {
      lineHtml = lineHtml.replace(/_{3,10}/g, () => {
        counter += 1;
        const key = String(counter);
        lineKeys.push(key);
        return `__BLANK_MARKER_${key}__`;
      });
    }

    if (window.hljs && language) {
      try {
        lineHtml = window.hljs.highlight(lineHtml, { language, ignoreIllegals: true }).value;
      } catch (e) {
        lineHtml = escapeHtml(lineHtml);
      }
    } else {
      lineHtml = escapeHtml(lineHtml);
    }

    lineKeys.forEach((key) => {
      const answer = answerKey[key];
      const dataAnswer = answer !== undefined ? ` data-answer="${escapeHtml(String(answer))}"` : "";
      const inputHtml = `<span class="placeholder" id="blank-${key}"><input type="text" class="blank" data-key="${key}"${dataAnswer} placeholder="#${key}"><button class="help-btn" data-key="${key}" title="??é®ë‰ë­ ?ã…»ì±¸">?</button><span class="answer-chip">#${key}</span></span>`;
      const markerRegex = new RegExp(`__BLANK_MARKER_${key}__`, 'g');
      lineHtml = lineHtml.replace(markerRegex, inputHtml);
    });

    codeText.innerHTML = lineHtml || "&nbsp;";
    lineElem.appendChild(lineNo);
    lineElem.appendChild(codeText);
    frag.appendChild(lineElem);
  });

  codeArea.appendChild(frag);

  const allInputs = codeArea.querySelectorAll("input.blank");
  inputs = Array.from(allInputs);

  inputs.forEach((input) => {
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleEnter(input);
      }
    });
  });

  // Add help button listeners
  codeArea.querySelectorAll(".help-btn").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      explainBlank(btn.dataset.key);
    });
  });

  sessionCount.textContent = inputs.length;
  hasAnswers = inputs.some((inp) => inp.dataset.answer !== undefined);
  updateScore();
  renderBlankNav();
}

// ========== PARSED QUIZ (æ¹²ê³—ã€ˆ è‡¾ëª„ì £ ?ëš¯ì”ª) ==========
let parsedQuizStates = [];
let originalQuestions = [];  // ?ë¨®ë‚¯ è‡¾ëª„ì £ ?ì’–ê½Œ ?Â€??let currentQuestions = [];   // ?ê¾©ì˜± ?ì’–ë–† ä»¥ë¬’ì”¤ è‡¾ëª„ì £ ?ì’–ê½Œ
let isShuffled = false;      // ?ìšì—« ?ê³¹ê¹­
let parsedQuizMap = new Map(); // qId -> è‡¾ëª„ì £ åª›ì•¹ê»œ

function renderParsedQuiz(questions, answerKey, language, preserveOrder = false) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  parsedQuizStates = [];
  parsedQuizMap = new Map();

  // ?ë¨®ë‚¯ ?ì’–ê½Œ ?Â€??(ï§£?æ¿¡ì’•ë±¶ ??
  if (!preserveOrder) {
    originalQuestions = [...questions];
    currentQuestions = [...questions];
    isShuffled = false;
    updateShuffleButton();
  }

  const frag = document.createDocumentFragment();

  questions.forEach((q, idx) => {
    const qId = q.id || (idx + 1);  // ?ë¨®ë‚¯ æ€¨ì¢ì‘€ ID
    const displayIdx = idx + 1;      // ?ê¾©ì˜± ?ì’–ë–† ?ì’–ê½Œ (1, 2, 3...)
    const displayNum = q.original_num || q.num || qId;
    const qType = q.type || "multiple_choice";

    const cardDiv = document.createElement("div");
    cardDiv.className = "mc-question";
    cardDiv.id = `pq-${qId}`;
    cardDiv.dataset.displayIdx = displayIdx;  // ?ê¾©ì˜± ?ì’–ë–† ?ì’–ê½Œ ?Â€??
    // è‡¾ëª„ì £ ?ã…»ëœ‘
    const headerDiv = document.createElement("div");
    headerDiv.className = "mc-header";

    // è‡¾ëª„ì £ ?ì¢ì‚ è«­ê»‹?
    const typeBadge = qType === "short_answer" ? "?ë±· ?â‘¤ë–Ÿ?? :
      qType === "fill_blank" ? "?ë¥…íˆ˜ é®ë‰ë­" : "?ë±¥ åª›ì•·???;

    // [Q#] ?ëº¤ë–‡?ì‡°ì¤ˆ ?ê¾©ë¿­ æ€¨ì¢ì‘€ ID ?ì’–ë–† - AIåª›Â€ æ´Ñ‰í…‡ åª›Â€??    headerDiv.innerHTML = `<span class="global-qid" style="background:var(--accent);color:#000;padding:2px 6px;border-radius:4px;font-size:0.75em;margin-right:6px;font-weight:bold;">[Q${qId}]</span> <span style="opacity:0.6;font-size:0.8em">${typeBadge}</span> <strong>${displayNum}.</strong> ${escapeHtml(q.text)}`;
    cardDiv.appendChild(headerDiv);

    // è‚„ë¶¾ë±¶ é‡‰ë¶¾ì¤‰
    if (q.code && q.code.trim()) {
      const codeDiv = document.createElement("pre");
      codeDiv.className = "mc-code";
      const langHint = language === "text" ? "python" : language;
      if (window.hljs && langHint) {
        try {
          codeDiv.innerHTML = window.hljs.highlight(q.code.trim(), { language: langHint, ignoreIllegals: true }).value;
        } catch (e) {
          codeDiv.textContent = q.code.trim();
        }
      } else {
        codeDiv.textContent = q.code.trim();
      }
      cardDiv.appendChild(codeDiv);
    }

    // ?ì¢? ?ë¨®ë’— ?ë‚…ì ° ?ê³¸ë¿­
    if (q.options && q.options.length > 0) {
      // åª›ì•·???      const optionsDiv = document.createElement("div");
      optionsDiv.className = "mc-options";

      q.options.forEach((opt) => {
        const optionBtn = document.createElement("button");
        optionBtn.className = "mc-option";
        optionBtn.dataset.question = String(qId);
        optionBtn.dataset.option = String(opt.num);
        // ?ëº£ë–Ÿ???ë‰ì‘ï§??Â€??(ï§¢ê¾©ì ??
        optionBtn.dataset.correct = q.correct ? String(q.correct) : "";

        const numSymbols = ["??, "??, "??, "??, "??];
        const symbol = numSymbols[opt.num - 1] || opt.num;

        optionBtn.innerHTML = `<span class="mc-option-num">${symbol}</span><span class="mc-option-text">${escapeHtml(opt.text)}</span>`;
        optionBtn.addEventListener("click", () => handleParsedQuizClick(optionBtn, qId));

        optionsDiv.appendChild(optionBtn);
      });

      cardDiv.appendChild(optionsDiv);
    } else {
      // ?â‘¤ë–Ÿ??é®ë‰ë­ - ?ë‚…ì ° ?ê¾¨ë±¶
      const inputDiv = document.createElement("div");
      inputDiv.className = "short-answer-input";
      inputDiv.style.cssText = "margin-top: 1rem;";

      const textarea = document.createElement("textarea");
      textarea.className = "challenge-textarea";
      textarea.id = `pq-input-${qId}`;
      textarea.placeholder = qType === "fill_blank" ? "é®ë‰ë­???ã…¼ë¼±åª›??ëŒìŠœ???ë‚…ì °?ì„ê½­??.." : "?ë“­ì“£ ?ë‚…ì °?ì„ê½­??.. (Enter=?ì’–í…§, Enter ??è¸°?AI ?ëº£ë–Ÿ)";
      textarea.rows = 2;
      textarea.style.cssText = "width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--fg); font-family: inherit; resize: vertical;";

      // ?ë·€ê½£ ??è¸°?= AI ?ëº£ë–Ÿ è¹‚ë‹¿ë¦°
      let lastEnterTime = 0;
      textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          const now = Date.now();
          if (now - lastEnterTime < 500) {
            // ?ë·€ê½£ ??è¸°?é®ì¢Šâ…¤å¯ƒ???AI ?ëº£ë–Ÿ è¹‚ë‹¿ë¦°
            e.preventDefault();
            showShortAnswerWithAI(qId, q.question, q.code || "");
          } else {
            // ï§£?è¸°ë‰ã ?ë·€ê½£ ???ì’–í…§
            e.preventDefault();
            handleShortAnswerSubmit(qId, textarea.value);
          }
          lastEnterTime = now;
        }
      });

      // è¸°ê¾ªë“‰??      const btnDiv = document.createElement("div");
      btnDiv.style.cssText = "display: flex; gap: 8px; margin-top: 0.5rem; flex-wrap: wrap;";

      const submitBtn = document.createElement("button");
      submitBtn.className = "challenge-btn";
      submitBtn.textContent = "?ì’–í…§";
      submitBtn.style.cssText = "padding: 0.5rem 1rem; background: var(--accent-2); color: #0f1117; border: none; border-radius: 6px; cursor: pointer;";
      submitBtn.addEventListener("click", () => handleShortAnswerSubmit(qId, textarea.value));

      const resetBtn = document.createElement("button");
      resetBtn.className = "challenge-btn";
      resetBtn.id = `pq-reset-${qId}`;
      resetBtn.textContent = "?ë´½ ?ã…¼ë–†";
      resetBtn.style.cssText = "padding: 0.5rem 1rem; background: var(--muted); color: var(--fg); border: none; border-radius: 6px; cursor: pointer;";
      resetBtn.addEventListener("click", () => resetShortAnswer(qId));

      const aiBtn = document.createElement("button");
      aiBtn.className = "challenge-btn";
      aiBtn.textContent = "?ë®• AI?ëº£ë–Ÿ";
      aiBtn.style.cssText = "padding: 0.5rem 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer;";
      aiBtn.addEventListener("click", () => showShortAnswerWithAI(qId, q.question, q.code || ""));

      btnDiv.appendChild(submitBtn);
      btnDiv.appendChild(resetBtn);
      btnDiv.appendChild(aiBtn);

      inputDiv.appendChild(textarea);
      inputDiv.appendChild(btnDiv);
      cardDiv.appendChild(inputDiv);
    }

    // å¯ƒê³Œë‚µ ?ì’–ë–†
    const resultDiv = document.createElement("div");
    resultDiv.className = "mc-result";
    resultDiv.id = `pq-result-${qId}`;
    cardDiv.appendChild(resultDiv);

    frag.appendChild(cardDiv);
    parsedQuizMap.set(qId, q);

    parsedQuizStates.push({
      qId,
      displayIdx,  // ?ê¾©ì˜± ?ì’–ë–† ?ì’–ê½Œ
      displayNum,
      qType,
      selected: null,
      answered: false,
      userAnswer: ""
    });
  });

  codeArea.appendChild(frag);
  renderParsedQuizNav();
  sessionCount.textContent = questions.length;
  hasAnswers = true;
  updateParsedQuizScore();
}

// ========== ?ì’–ê½Œ ?ìšŠë¦° æ¹²ê³•ë’« ==========
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function shuffleQuestions() {
  if (!currentSession?.answer_key?._questions) return;

  const answerKey = currentSession.answer_key;
  const language = currentSession.language;

  // è‡¾ëª„ì £ ?ì’–ê½Œ ?ìšŠë¦°
  currentQuestions = shuffleArray(originalQuestions);
  isShuffled = true;

  // ?ã…¼ë–† ?ëš®ëœ‘ï§?  renderParsedQuiz(currentQuestions, answerKey, language, true);
  updateShuffleButton();

  // ?ã…½ê²•æ¿¡?ï§??ê¾¨ì¤ˆ
  window.scrollTo({ top: 0, behavior: "smooth" });
}

function resetQuizOrder() {
  if (!currentSession?.answer_key?._questions) return;

  const answerKey = currentSession.answer_key;
  const language = currentSession.language;

  // ?ë¨®ë‚¯ ?ì’–ê½Œæ¿¡?è¹‚ë“­ì
  currentQuestions = [...originalQuestions];
  isShuffled = false;

  // ?ã…¼ë–† ?ëš®ëœ‘ï§?  renderParsedQuiz(currentQuestions, answerKey, language, true);
  updateShuffleButton();

  // ?ã…½ê²•æ¿¡?ï§??ê¾¨ì¤ˆ
  window.scrollTo({ top: 0, behavior: "smooth" });
}

function updateShuffleButton() {
  const btn = document.getElementById("btn-shuffle");
  if (!btn) return;

  if (isShuffled) {
    btn.textContent = "?ë±¥ ?ë¨®ì˜’ ?ì’–ê½Œæ¿¡?;
    btn.classList.add("shuffled");
  } else {
    btn.textContent = "?? ?ì’–ê½Œ ?ìšŠë¦°";
    btn.classList.remove("shuffled");
  }
}

function toggleShuffle() {
  // 4è¸°?ï§â‘¤ë±¶ (åª›ì•·???
  if (currentSession?.answer_key?._questions) {
    if (isShuffled) {
      resetQuizOrder();
    } else {
      shuffleQuestions();
    }
    return;
  }

  // 5è¸°?ï§â‘¤ë±¶ (?ëº¤ì“½ ?ëŒì«°)
  if (definitionStates && definitionStates.length > 0) {
    shuffleDefinitions();
    return;
  }

  // 7è¸°?ï§â‘¤ë±¶ (?ê³·ë–’??
  if (vocabStates && vocabStates.length > 0) {
    shuffleVocab();
    return;
  }
}

// ?ëº¤ì“½ ?ëŒì«° ?ì’–ê½Œ ?ìšŠë¦°
function shuffleDefinitions() {
  const container = document.getElementById('definition-container') || codeBlock;
  if (!container) return;

  const cards = Array.from(container.querySelectorAll('.definition-card'));
  if (cards.length === 0) return;

  // Fisher-Yates ?ë·€ëµ†
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    container.appendChild(cards[j]);
  }

  // ï§â‘¤ë±º ç§»ëŒ€ë±¶ ?ã…¼ë–† ç•°ë¶½? (?ì’–ê½Œ ?ìšì”¤ ?ê³¹ê¹­æ¿¡?
  cards.sort(() => Math.random() - 0.5).forEach(card => container.appendChild(card));

  window.scrollTo({ top: 0, behavior: 'smooth' });

  const btn = document.getElementById('btn-shuffle');
  if (btn) btn.textContent = '?? ?ã…¼ë–† ?ìšŠë¦°';
}

// ?ê³·ë–’???ì’–ê½Œ ?ìšŠë¦°
function shuffleVocab() {
  const container = document.getElementById('vocab-container') || codeBlock;
  if (!container) return;

  const cards = Array.from(container.querySelectorAll('.vocab-card'));
  if (cards.length === 0) return;

  // Fisher-Yates ?ë·€ëµ†
  cards.sort(() => Math.random() - 0.5).forEach(card => container.appendChild(card));

  window.scrollTo({ top: 0, behavior: 'smooth' });

  const btn = document.getElementById('btn-shuffle');
  if (btn) btn.textContent = '?? ?ã…¼ë–† ?ìšŠë¦°';
}

function handleParsedQuizClick(btn, qId) {
  const selectedOption = btn.dataset.option;
  const correctAnswer = btn.dataset.correct;  // ?ëº£ë–Ÿ (?ë‰ì‘ï§?
  const state = parsedQuizStates.find(s => s.qId === qId);

  if (state?.answered) return;

  // ?ê³¹ê¹­ ?ë‚…ëœ²?ëŒ„ë“ƒ
  if (state) {
    state.answered = true;
    state.selected = selectedOption;
    state.correctAnswer = correctAnswer;
    state.isCorrect = correctAnswer && selectedOption === correctAnswer;
  }

  const cardDiv = document.getElementById(`pq-${qId}`);
  const options = cardDiv.querySelectorAll(".mc-option");
  const resultDiv = document.getElementById(`pq-result-${qId}`);
  const nav = document.getElementById(`nav-pq-${qId}`);

  // ?ëº£ë–Ÿ???ë‰ì‘ï§?ï§¢ê¾©ì 
  if (correctAnswer) {
    const isCorrect = selectedOption === correctAnswer;

    options.forEach(opt => {
      opt.disabled = true;
      if (opt.dataset.option === correctAnswer) {
        opt.classList.add("correct");  // ?ëº£ë–Ÿ?Â€ ??ê¸½ ?ë±€ê¹‹
      }
      if (opt.dataset.option === selectedOption && !isCorrect) {
        opt.classList.add("wrong");  // ?ã…»ë–Ÿ?ëŒ€ãˆƒ é®â‘£ì»™??      }
      if (opt.dataset.option === selectedOption && isCorrect) {
        opt.classList.add("correct");
      }
    });

    if (isCorrect) {
      resultDiv.innerHTML = `<span style="color: var(--green);">???ëº£ë–Ÿ! (${selectedOption}è¸°?</span>`;
      if (nav) {
        nav.classList.remove("pending");
        nav.classList.add("correct");
      }
    } else {
      resultDiv.innerHTML = `<span style="color: var(--red);">???ã…»ë–Ÿ! ?ëº£ë–Ÿ?Â€ ${correctAnswer}è¸°?/span>`;
      if (nav) {
        nav.classList.remove("pending");
        nav.classList.add("wrong");
      }
    }
  } else {
    // ?ëº£ë–Ÿ ?ë†ì‘ï§??ì¢ê¹®ï§??ì’–ë–†
    options.forEach(opt => {
      opt.disabled = true;
      if (opt.dataset.option === selectedOption) {
        opt.classList.add("selected");
      }
    });
    resultDiv.innerHTML = `<span style="color: var(--accent-2);">??${selectedOption}è¸°??ì¢ê¹®??/span>`;
    if (nav) {
      nav.classList.remove("pending");
      nav.classList.add("correct");
    }
  }

  updateParsedQuizScore();
}

// ?â‘¤ë–Ÿ??é®ë‰ë­ ?ì’–í…§ ?ëªƒë±¾??(AI ï§¢ê¾©ì )
async function handleShortAnswerSubmit(qId, answer) {
  const state = parsedQuizStates.find(s => s.qId === qId);

  if (state?.isCorrect) return;

  if (!answer.trim()) {
    alert("?ë“­ì“£ ?ë‚…ì °?ëŒï¼œ?ëª„ìŠ‚.");
    return;
  }

  const textarea = document.getElementById(`pq-input-${qId}`);
  const resultDiv = document.getElementById(`pq-result-${qId}`);

  resultDiv.innerHTML = `<span style="color: var(--accent-2);">AIåª›Â€ ï§¢ê¾©ì  ä»¥?..</span>`;

  try {
    const questionCard = document.getElementById(`pq-${qId}`);
    const questionText = questionCard?.querySelector('.parsed-quiz-question')?.textContent || '';
    const codeText = questionCard?.querySelector('pre')?.textContent || '';

    const qObj = parsedQuizMap.get(qId) || {};
    const expected = qObj.answer || currentSession?.answer_key?.[String(qId)];
    const normalize = (s) => s.replace(/\s+/g, ' ').trim();

    let isCorrect = false;
    let gradedBy = "ai";

    if (expected && normalize(expected) === normalize(answer)) {
      isCorrect = true;
      gradedBy = "exact";
    }

    if (!isCorrect) {
      isCorrect = await checkShortAnswerWithAI(questionText, codeText, answer.trim());
    }

    if (state) {
      state.answered = isCorrect;
      state.userAnswer = answer.trim();
      state.isCorrect = isCorrect;
    }

    if (isCorrect) {
      if (textarea) {
        textarea.style.background = "rgba(94, 230, 167, 0.1)";
        textarea.style.borderColor = "var(--green)";
        textarea.disabled = false;
      }
      resultDiv.innerHTML = `<span class="mc-correct">?ëº£ë–Ÿ! ${gradedBy === "exact" ? "?ëº¥ì†—???ì‡±íŠ‚?â‘¸ë•²??" : "AIåª›Â€ ?ëª„ì ™?ë‰ë’¿?ëˆë–."}</span>`;
      LearningStats.recordAnswer(true);
      SoundEffects.play('correct');
    } else {
      if (textarea) {
        textarea.style.background = "rgba(255, 107, 107, 0.1)";
        textarea.style.borderColor = "var(--red)";
        textarea.disabled = false;
      }
      resultDiv.innerHTML = `<span class="mc-wrong">?ã…»ë–Ÿ?ë‚…ë•²?? ?ã…¼ë–† ?ì•·ì»–?ëŒ€ë‚«?ëª„ìŠ‚.</span>`;
      LearningStats.recordAnswer(false);
      SoundEffects.play('wrong');
      if (state) state.answered = false;
    }

    const nav = document.getElementById(`nav-pq-${qId}`);
    if (nav) {
      nav.classList.remove("pending");
      nav.classList.add(isCorrect ? "correct" : "wrong");
    }

    updateParsedQuizScore();

  } catch (err) {
    resultDiv.innerHTML = `<span class="mc-wrong">ï§¢ê¾©ì  ?ã…»ìªŸ: ${err.message}</span>`;
  }
}

// ?â‘¤ë–Ÿ??AI ï§¢ê¾©ì  (ï§ã…¼ìŠ¦ ?ê¾§êº½)
async function checkShortAnswerWithAI(question, code, userAnswer) {
  const prompt = `?ë±€ë–Š?Â€ ï§ã…¼ìŠ¦ ?ê¾§êº½???ê¾¨ì¤ˆæ´¹ëªƒì˜’è«›??ì’—ë¿• ï§¢ê¾©ì æ„¿Â€?ë‚…ë•²?? ?ìˆˆê¹®?ã…¼ì“½ ?ë¨¯ë‹”ç‘œ??ê¾ªë¸¯å¯ƒ?äºŒì‡±? ?ë”†ë’¿?ëˆë–.

## è‡¾ëª„ì £
${question}

${code ? `## æ„¿Â€??è‚„ë¶¾ë±¶\n\`\`\`\n${code}\n\`\`\`` : ''}

## ?ìˆˆê¹®????"${userAnswer}"

## ï§¢ê¾©ì  æ¹²ê³—? (ï§ã…¼ìŠ¦ ?ê¾§êº½)
1. ?ëº¥ì†—??åª›ë¯ªì” ??å¯ƒê³Œë‚µ?ÑŠë¹ ??2. ?Â€?ë“­ìŸ»???ë“­ì” ???ã…»ì±¸?Â€ ?ã…»ë–Ÿ
3. ?ãƒ¬ì˜„ è‡¾ëª„ì £???ëº¥ì†—???ãƒ¬ì˜„?ÑŠë¹ ??4. ç•°ì’•ì ° å¯ƒê³Œë‚µ è‡¾ëª„ì £???ëº¥ì†—??ç•°ì’•ì °?ëŒë¼±????5. ?ì„??ë…¿ë’— ?ë“­ì” ???ê¾©ì“½???ë“­? è‡¾ëŒâ€œå«„??ã…»ë–Ÿ
6. ?ëº¤ë–Š???ë†ì‘ï§??ã…»ë–Ÿ?ì‡°ì¤ˆ ï§£ì„â”

## ?ë¬ë–Ÿ (???â‘¥ë¼±ï§?
- 100% ?ëº¤ë–???ëº£ë–Ÿ?ëŒ€ãˆƒ: CORRECT
- æ´¹???ï§â‘¤ë±º å¯ƒìŒìŠ¦: WRONG`;

  try {
    const response = await callGeminiAPI(prompt, "You are an extremely strict exam grader. When in doubt, mark as WRONG.");
    const upperResponse = response.toUpperCase().trim();
    // "CORRECT"åª›Â€ ï§ë‚‡ì†—???ë‡í€¬ "WRONG"???ë†ì“£ ?ëš®ì­” ?ëº£ë–Ÿ
    if (upperResponse.includes("CORRECT") && !upperResponse.includes("WRONG")) {
      return true;
    }
    return false; // æ¹²ê³•ë‚¯åª›ë¯ª? ?ã…»ë–Ÿ
  } catch (err) {
    console.error("AI ï§¢ê¾©ì  ?ã…»ìªŸ:", err);
    return false; // API ?ã…½ë™£ ???ã…»ë–Ÿ
  }
}

// ?â‘¤ë–Ÿ???ã…¼ë–† ?Â€æ¹²?function resetShortAnswer(qId) {
  const state = parsedQuizStates.find(s => s.qId === qId);
  if (!state) return;

  const textarea = document.getElementById(`pq-input-${qId}`);
  const resultDiv = document.getElementById(`pq-result-${qId}`);
  const nav = document.getElementById(`nav-pq-${qId}`);

  // ?ê³¹ê¹­ ç¥ë‡ë¦°??  state.answered = false;
  state.isCorrect = null;
  state.userAnswer = "";

  // UI ç¥ë‡ë¦°??  if (textarea) {
    textarea.value = "";
    textarea.disabled = false;
    textarea.style.background = "rgba(255,255,255,0.05)";
    textarea.style.borderColor = "rgba(255,255,255,0.1)";
    textarea.focus();
  }

  if (resultDiv) {
    resultDiv.innerHTML = "";
  }

  if (nav) {
    nav.classList.remove("correct", "wrong");
    nav.classList.add("pending");
  }

  updateParsedQuizScore();
}

// AI ?ëº£ë–Ÿ è¹‚ë‹¿ë¦°
async function showShortAnswerWithAI(qId, question, code) {
  const resultDiv = document.getElementById(`pq-result-${qId}`);
  const state = parsedQuizStates.find(s => s.qId === qId);

  resultDiv.innerHTML = `<span style="color: var(--accent-2);">?ì¨º AIåª›Â€ ?ëº£ë–Ÿ??éºê¾©ê½ ä»¥?..</span>`;

  const prompt = `?ë±€ë–Š?Â€ ?ê¾¨ì¤ˆæ´¹ëªƒì˜’è«›?è‡¾ëª„ì £ ?ëŒê½•?ë¨¯ì—¯?ëˆë–.

## è‡¾ëª„ì £
${question}

${code ? `## è‚„ë¶¾ë±¶\n\`\`\`\n${code}\n\`\`\`` : ''}

??è‡¾ëª„ì £???ëº£ë–Ÿæ€¨?åª›ê¾¨ë–’???ëŒê½•???ëš®ì ®äºŒì‡±ê½­??
- ?ëº£ë–Ÿ??ç™’ì‡±? ï§ë‚‡ì†—?ì„ì¾¶ ?ì’–ë–†
- ??æ´¹??ë“­ì”¤ï§Â€ 1-2ä»¥ê¾¨ì¤ˆ ?ã…»ì±¸

?ëº¤ë–‡: "?ëº£ë–Ÿ: [?? / ?ëŒê½•: [?ã…»ì±¸]"`;

  try {
    const response = await callGeminiAPI(prompt, "Provide the correct answer clearly.");

    // ?ëº£ë–Ÿ ?ì’–ë–†
    resultDiv.innerHTML = `
      <div style="background: rgba(102, 126, 234, 0.1); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 8px; padding: 12px; margin-top: 8px;">
        <div style="color: #667eea; font-weight: bold; margin-bottom: 6px;">?ë®• AI ?ëº£ë–Ÿ</div>
        <div style="color: var(--fg);">${escapeHtml(response)}</div>
      </div>`;

    // ?ê³¹ê¹­ ?ë‚…ëœ²?ëŒ„ë“ƒ (?ëº£ë–Ÿ éŠê¾©ì‘æ¿¡??ì’–ë–†)
    if (state && !state.answered) {
      state.answered = true;
      state.isCorrect = false; // ?ëº£ë–Ÿ??éŠã…¼ì‘èª˜Â€æ¿¡??Â€ç”±?å¯ƒê»‹ì‘æ¿¡?ï§£ì„â”
    }

    const nav = document.getElementById(`nav-pq-${qId}`);
    if (nav) {
      nav.classList.remove("pending");
      nav.classList.add("revealed");
    }

    updateParsedQuizScore();

  } catch (err) {
    resultDiv.innerHTML = `<span class="mc-wrong">??AI ?ã…»ìªŸ: ${err.message}</span>`;
  }
}

function renderParsedQuizNav() {
  blankList.innerHTML = "";
  parsedQuizStates.forEach((s, idx) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-pq-${s.qId}`;
    btn.textContent = `${idx + 1}`;  // ?ì’–ê° è¸°ëŠìƒ‡ (1, 2, 3...)
    btn.title = `[Q${s.qId}] ${s.displayNum}è¸°?;  // ?ëŒ„ë˜»???ê¾©ë¿­ ID + ?ë¨®ë‚¯ è¸°ëŠìƒ‡
    btn.addEventListener("click", () => {
      const target = document.getElementById(`pq-${s.qId}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
    });
    blankList.appendChild(btn);
  });
}

function updateParsedQuizScore() {
  const total = parsedQuizStates.length;
  const answered = parsedQuizStates.filter(s => s.answered).length;
  const correct = parsedQuizStates.filter(s => s.isCorrect === true).length;
  const wrong = parsedQuizStates.filter(s => s.answered && s.isCorrect === false && s.correctAnswer).length;

  // ï§¢ê¾©ì  åª›Â€?Î½ë¸³ è‡¾ëª„ì £åª›Â€ ?ë‰ì‘ï§??ë¨¯ë‹” ?ì’–ë–†
  const hasGradedQuestions = parsedQuizStates.some(s => s.correctAnswer);

  if (hasGradedQuestions && answered > 0) {
    sessionScore.textContent = `??{correct} ??{wrong} / ${total}`;
    sessionScore.style.color = correct > wrong ? "var(--green)" : "var(--red)";
  } else {
    sessionScore.textContent = `${answered} / ${total} ?ê¾¨ì¦º`;
    sessionScore.style.color = "";
  }

  const ratio = total ? (answered / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    if (answered === total && hasGradedQuestions) {
      const percentage = Math.round((correct / total) * 100);
      reviewBadge.textContent = `ï§¤ì’–ì¥Œ ?ë¨¯ë‹”: ${correct}/${total} (${percentage}%)`;
      reviewBadge.style.color = percentage >= 60 ? "var(--green)" : "var(--red)";
    } else if (answered === total) {
      reviewBadge.textContent = "ï§â‘¤ëª¢ ?ê¾¨ì¦º!";
    } else {
      reviewBadge.textContent = `?â‘¥? è‡¾ëª„ì £ ${total - answered}åª›?;
    }
  }
}

// ========== MULTIPLE CHOICE (è‚„ë¶¾ë±¶ ?ì•¹ê½¦) ==========
function renderMultipleChoiceNew(questions, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  mcQuestions = [];

  const frag = document.createDocumentFragment();

  questions.forEach((q, idx) => {
    const qNum = q.num || (idx + 1);
    const correctAnswer = q.correct ? String(q.correct) : answerKey[String(qNum)];

    const cardDiv = document.createElement("div");
    cardDiv.className = "mc-question";
    cardDiv.id = `mc-${qNum}`;

    // è‡¾ëª„ì £ ?ã…»ëœ‘
    const headerDiv = document.createElement("div");
    headerDiv.className = "mc-header";
    headerDiv.innerHTML = `<strong>[è‡¾ëª„ì £ ${qNum}]</strong> ${escapeHtml(q.text)}`;
    cardDiv.appendChild(headerDiv);

    // è‚„ë¶¾ë±¶ é‡‰ë¶¾ì¤‰
    if (q.code) {
      const codeDiv = document.createElement("pre");
      codeDiv.className = "mc-code";
      if (window.hljs && language) {
        try {
          codeDiv.innerHTML = window.hljs.highlight(q.code.trim(), { language, ignoreIllegals: true }).value;
        } catch (e) {
          codeDiv.textContent = q.code.trim();
        }
      } else {
        codeDiv.textContent = q.code.trim();
      }
      cardDiv.appendChild(codeDiv);
    }

    // ?ì¢?
    const optionsDiv = document.createElement("div");
    optionsDiv.className = "mc-options";

    q.options.forEach((opt) => {
      const optionBtn = document.createElement("button");
      optionBtn.className = "mc-option";
      optionBtn.dataset.question = String(qNum);
      optionBtn.dataset.option = String(opt.num);
      optionBtn.dataset.correct = correctAnswer;

      optionBtn.innerHTML = `<span class="mc-option-num">${opt.num}</span><span class="mc-option-text">${escapeHtml(opt.text)}</span>`;
      optionBtn.addEventListener("click", () => handleMCClick(optionBtn));

      optionsDiv.appendChild(optionBtn);
    });

    cardDiv.appendChild(optionsDiv);

    // å¯ƒê³Œë‚µ
    const resultDiv = document.createElement("div");
    resultDiv.className = "mc-result";
    resultDiv.id = `mc-result-${qNum}`;
    cardDiv.appendChild(resultDiv);

    frag.appendChild(cardDiv);

    mcQuestions.push({
      questionNum: qNum,
      correctAnswer,
      answered: false,
      isCorrect: null
    });
  });

  codeArea.appendChild(frag);
  renderMCNav();
  sessionCount.textContent = questions.length;
  hasAnswers = true;
  updateMCScore();
}

// ========== MULTIPLE CHOICE (Legacy) ==========
let mcQuestions = []; // åª›ì•·???è‡¾ëª„ì £ ?ê³¹ê¹­ ?Â€??
function renderMultipleChoice(questions, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  mcQuestions = [];

  const frag = document.createDocumentFragment();

  questions.forEach((questionText, idx) => {
    const questionNum = idx + 1;
    const correctAnswer = answerKey[String(questionNum)];
    const details = answerKey._details?.[String(questionNum)];

    // è‡¾ëª„ì £ è€Œâ‘¦ë€’?ëŒ€ê¼«
    const questionDiv = document.createElement("div");
    questionDiv.className = "mc-question";
    questionDiv.id = `mc-${questionNum}`;

    // è‡¾ëª„ì £ ?ëš¯ë–› (?ë¿ë’ª?ëª„ë¿‰??è‚„ë¶¾ë±¶?Â€ ?ì¢? éºê¾¨â”)
    const parts = questionText.split(/```python\n/);
    const header = parts[0] || "";
    const rest = parts[1]?.split(/```\n/) || ["", ""];
    const codeBlock = rest[0] || "";
    const optionsText = rest[1] || "";

    // è‡¾ëª„ì £ ?ã…»ëœ‘
    const headerDiv = document.createElement("div");
    headerDiv.className = "mc-header";
    headerDiv.innerHTML = escapeHtml(header.trim());
    questionDiv.appendChild(headerDiv);

    // è‚„ë¶¾ë±¶ é‡‰ë¶¾ì¤‰
    if (codeBlock) {
      const codeDiv = document.createElement("pre");
      codeDiv.className = "mc-code";
      if (window.hljs && language) {
        try {
          codeDiv.innerHTML = window.hljs.highlight(codeBlock.trim(), { language, ignoreIllegals: true }).value;
        } catch (e) {
          codeDiv.textContent = codeBlock.trim();
        }
      } else {
        codeDiv.textContent = codeBlock.trim();
      }
      questionDiv.appendChild(codeDiv);
    }

    // ?ì¢? ?ëš¯ë–› è«›??ëš®ëœ‘ï§?    const optionsDiv = document.createElement("div");
    optionsDiv.className = "mc-options";

    const optionLines = optionsText.trim().split("\n").filter(line => /^\s*\d+\./.test(line));
    optionLines.forEach((line) => {
      const match = line.match(/^\s*(\d+)\.\s*(.+)$/);
      if (!match) return;

      const optionNum = match[1];
      const optionText = match[2];

      const optionBtn = document.createElement("button");
      optionBtn.className = "mc-option";
      optionBtn.dataset.question = String(questionNum);
      optionBtn.dataset.option = optionNum;
      optionBtn.dataset.correct = correctAnswer;

      optionBtn.innerHTML = `<span class="mc-option-num">${optionNum}</span><span class="mc-option-text">${escapeHtml(optionText)}</span>`;

      optionBtn.addEventListener("click", () => handleMCClick(optionBtn));

      optionsDiv.appendChild(optionBtn);
    });

    questionDiv.appendChild(optionsDiv);

    // å¯ƒê³Œë‚µ ?ì’–ë–† ?ê³¸ë¿­
    const resultDiv = document.createElement("div");
    resultDiv.className = "mc-result";
    resultDiv.id = `mc-result-${questionNum}`;
    questionDiv.appendChild(resultDiv);

    frag.appendChild(questionDiv);

    // ?ê³¹ê¹­ ?Â€??    mcQuestions.push({
      questionNum,
      correctAnswer,
      answered: false,
      isCorrect: null
    });
  });

  codeArea.appendChild(frag);

  // é®ë‰ë­ ï§â‘¸ì¤‰ ?Â€??è‡¾ëª„ì £ ï§â‘¸ì¤‰ ?ëš®ëœ‘ï§?  renderMCNav();

  sessionCount.textContent = questions.length;
  hasAnswers = true;
  updateMCScore();
}

function handleMCClick(btn) {
  const questionNum = parseInt(btn.dataset.question);
  const selectedOption = btn.dataset.option;
  const correctOption = btn.dataset.correct;

  // ?ëŒ€? ?ë“¯ë¸³ è‡¾ëª„ì £ï§?è‡¾ëŒë–†
  const questionState = mcQuestions.find(q => q.questionNum === questionNum);
  if (questionState?.answered) return;

  const isCorrect = selectedOption === correctOption;

  // ?ê³¹ê¹­ ?ë‚…ëœ²?ëŒ„ë“ƒ
  if (questionState) {
    questionState.answered = true;
    questionState.isCorrect = isCorrect;
  }

  // UI ?ë‚…ëœ²?ëŒ„ë“ƒ
  const questionDiv = document.getElementById(`mc-${questionNum}`);
  const options = questionDiv.querySelectorAll(".mc-option");

  options.forEach(opt => {
    opt.disabled = true;
    if (opt.dataset.option === correctOption) {
      opt.classList.add("correct");
    }
    if (opt.dataset.option === selectedOption && !isCorrect) {
      opt.classList.add("wrong");
    }
  });

  // å¯ƒê³Œë‚µ ï§ë¶¿ë–†ï§Â€
  const resultDiv = document.getElementById(`mc-result-${questionNum}`);
  if (isCorrect) {
    resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ?ë‚…ë•²??</span>`;
  } else {
    resultDiv.innerHTML = `<span class="mc-wrong">???ã…»ë–Ÿ?ë‚…ë•²?? ?ëº£ë–Ÿ: ${correctOption}è¸°?/span>`;
  }

  // ?ã…»í‰¬å¯ƒëš¯ì” ???ë‚…ëœ²?ëŒ„ë“ƒ
  const nav = document.getElementById(`nav-mc-${questionNum}`);
  if (nav) {
    nav.classList.remove("pending");
    nav.classList.add(isCorrect ? "correct" : "revealed");
  }

  updateMCScore();
}

function renderMCNav() {
  blankList.innerHTML = "";
  mcQuestions.forEach((q) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-mc-${q.questionNum}`;
    btn.textContent = `Q${q.questionNum}`;
    btn.addEventListener("click", () => {
      const target = document.getElementById(`mc-${q.questionNum}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
    });
    blankList.appendChild(btn);
  });
}

function updateMCScore() {
  const total = mcQuestions.length;
  const answered = mcQuestions.filter(q => q.answered).length;
  const correct = mcQuestions.filter(q => q.isCorrect).length;

  sessionScore.textContent = `${correct} / ${total}`;
  const ratio = total ? (correct / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    if (answered === total) {
      reviewBadge.textContent = `?ê¾¨ì¦º! ${correct}/${total}`;
    } else {
      reviewBadge.textContent = `ï§ê¾ªë»¾ ä»¥?${answered}/${total}`;
    }
  }
}

// ========== FILL IN BLANK CARDS (Mode 1/2) ==========
let blankCardStates = [];

function renderBlankCards(blanks, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  blankCardStates = [];

  const frag = document.createDocumentFragment();

  blanks.forEach((blank, idx) => {
    const cardNum = idx + 1;
    const answer = blank.answer;

    const cardDiv = document.createElement("div");
    cardDiv.className = "blank-card";
    cardDiv.id = `blank-card-${cardNum}`;

    // ?ã…»ëœ‘
    const headerDiv = document.createElement("div");
    headerDiv.className = "blank-card-header";
    headerDiv.innerHTML = `<span class="blank-card-num">#${cardNum}</span> <span class="blank-card-line">Line ${blank.line_num}</span>`;
    cardDiv.appendChild(headerDiv);

    // è‚„ë¶¾ë±¶ è€Œâ‘¦ë€“?ã…½ë“ƒ
    const codeDiv = document.createElement("pre");
    codeDiv.className = "blank-card-code";

    // è‚„ë¶¾ë±¶?ë¨¯ê½Œ _____ ç‘œ?input?ì‡°ì¤ˆ è¹‚Â€??    let codeHtml = blank.context;
    if (window.hljs && language) {
      try {
        codeHtml = window.hljs.highlight(blank.context, { language, ignoreIllegals: true }).value;
      } catch (e) {
        codeHtml = escapeHtml(blank.context);
      }
    } else {
      codeHtml = escapeHtml(blank.context);
    }

    // _____ ç‘œ?input?ì‡°ì¤ˆ è¹‚Â€??    codeHtml = codeHtml.replace(/_____/g,
      `<input type="text" class="blank-card-input" data-key="${cardNum}" data-answer="${escapeHtml(answer)}" placeholder="?ëº£ë–Ÿ ?ë‚…ì °">`
    );

    codeDiv.innerHTML = codeHtml;
    cardDiv.appendChild(codeDiv);

    // å¯ƒê³Œë‚µ ?ì’–ë–†
    const resultDiv = document.createElement("div");
    resultDiv.className = "blank-card-result";
    resultDiv.id = `blank-result-${cardNum}`;
    cardDiv.appendChild(resultDiv);

    // ?ê¾©?ï§?è¸°ê¾ªë“‰
    const helpBtn = document.createElement("button");
    helpBtn.className = "help-btn blank-card-help";
    helpBtn.textContent = "?";
    helpBtn.title = "??é®ë‰ë­ ?ã…»ì±¸";
    helpBtn.addEventListener("click", () => explainBlank(String(cardNum)));
    cardDiv.appendChild(helpBtn);

    frag.appendChild(cardDiv);

    blankCardStates.push({
      cardNum,
      answer,
      answered: false,
      isCorrect: null
    });
  });

  codeArea.appendChild(frag);

  // input???ëŒ€ê¹½??è«›ë¶¿ì”¤??  const allInputs = codeArea.querySelectorAll(".blank-card-input");
  inputs = Array.from(allInputs);

  inputs.forEach((input) => {
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleBlankCardEnter(input);
      }
    });
  });

  renderBlankCardNav();
  sessionCount.textContent = blanks.length;
  hasAnswers = true;
  updateBlankCardScore();
}

function handleBlankCardEnter(input) {
  const cardNum = parseInt(input.dataset.key);
  const expected = input.dataset.answer;
  const userAnswer = input.value.trim();

  if (!userAnswer) return;

  const isCorrect = userAnswer === expected;
  const state = blankCardStates.find(s => s.cardNum === cardNum);

  if (state) {
    state.answered = true;
    state.isCorrect = isCorrect;
  }

  // UI ?ë‚…ëœ²?ëŒ„ë“ƒ
  input.disabled = true;
  input.classList.add(isCorrect ? "correct" : "wrong");

  const resultDiv = document.getElementById(`blank-result-${cardNum}`);
  if (isCorrect) {
    resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ!</span>`;
  } else {
    input.value = expected;
    input.classList.remove("wrong");
    input.classList.add("revealed");
    resultDiv.innerHTML = `<span class="mc-wrong">???ã…»ë–Ÿ ???ëº£ë–Ÿ: ${expected}</span>`;
  }

  // ?ã…»í‰¬å¯ƒëš¯ì” ???ë‚…ëœ²?ëŒ„ë“ƒ
  const nav = document.getElementById(`nav-blank-${cardNum}`);
  if (nav) {
    nav.classList.remove("pending");
    nav.classList.add(isCorrect ? "correct" : "revealed");
  }

  updateBlankCardScore();

  // ?ã…¼ì“¬ ?ë‚…ì °?ì‡°ì¤ˆ ?ÑŠë¹±??  const nextInput = inputs.find(inp => !inp.disabled);
  if (nextInput) nextInput.focus();
}

function renderBlankCardNav() {
  blankList.innerHTML = "";
  blankCardStates.forEach((s) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-blank-${s.cardNum}`;
    btn.textContent = `#${s.cardNum}`;
    btn.addEventListener("click", () => {
      const target = document.getElementById(`blank-card-${s.cardNum}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
      const input = target?.querySelector("input");
      if (input && !input.disabled) input.focus();
    });
    blankList.appendChild(btn);
  });
}

function updateBlankCardScore() {
  const total = blankCardStates.length;
  const correct = blankCardStates.filter(s => s.isCorrect).length;
  const answered = blankCardStates.filter(s => s.answered).length;

  sessionScore.textContent = `${correct} / ${total}`;
  const ratio = total ? (correct / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    const remaining = total - answered;
    if (remaining === 0) {
      reviewBadge.textContent = `?ê¾¨ì¦º! ${correct}/${total}`;
    } else {
      reviewBadge.textContent = `?â‘¥? è‡¾ëª„ì £ ${remaining}åª›?;
    }
  }
}

// ========== IMPLEMENTATION CHALLENGE (Mode 3) ==========
let challengeStates = [];

function renderImplementationChallenge(challenges, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  challengeStates = [];

  const frag = document.createDocumentFragment();

  challenges.forEach((ch, idx) => {
    const challengeNum = idx + 1;
    const answer = ch.body;

    const cardDiv = document.createElement("div");
    cardDiv.className = "challenge-card";
    cardDiv.id = `challenge-${challengeNum}`;

    // ?ã…»ëœ‘
    const headerDiv = document.createElement("div");
    headerDiv.className = "challenge-header";
    headerDiv.innerHTML = `<span class="challenge-num">ï§¢ëš®â”›ï§Â€ ${challengeNum}</span>`;
    cardDiv.appendChild(headerDiv);

    // ?â‘¥ë‹” ?ì’“ë ‡?ë‰ì¿‚
    const sigDiv = document.createElement("pre");
    sigDiv.className = "challenge-signature";
    if (window.hljs && language) {
      try {
        sigDiv.innerHTML = window.hljs.highlight(ch.signature, { language, ignoreIllegals: true }).value;
      } catch (e) {
        sigDiv.textContent = ch.signature;
      }
    } else {
      sigDiv.textContent = ch.signature;
    }
    cardDiv.appendChild(sigDiv);

    // ?ëš°ë“ƒ
    const hintDiv = document.createElement("div");
    hintDiv.className = "challenge-hint";
    hintDiv.textContent = "???ê¾¨ì˜’???â‘¥ë‹” è¹‚ëªƒĞ¦??æ´Ñ‹ì½?ì„ê½­??;
    cardDiv.appendChild(hintDiv);

    // ?ë‚…ì ° ?ê³¸ë¿­
    const textarea = document.createElement("textarea");
    textarea.className = "challenge-input";
    textarea.dataset.key = String(challengeNum);
    textarea.dataset.answer = answer;
    textarea.placeholder = "    # ?Ñˆë¦°??è‚„ë¶¾ë±¶ æ´Ñ‹ì½...";
    textarea.rows = 8;
    textarea.spellcheck = false;

    // Python ?ë¨®ë£ ?ã…¼ë¿¬?ê³Œë¦° è«›?Enter ??ï§¢ê¾©ì 
    textarea.addEventListener("keydown", (e) => {
      // Tab ?? ?ã…¼ë¿¬?ê³Œë¦° ç•°ë¶½?
      if (e.key === "Tab" && !e.shiftKey) {
        e.preventDefault();
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const value = textarea.value;
        textarea.value = value.substring(0, start) + "    " + value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + 4;
        return;
      }

      // Shift+Tab: ?ã…¼ë¿¬?ê³Œë¦° ?ì’“êµ…
      if (e.key === "Tab" && e.shiftKey) {
        e.preventDefault();
        const start = textarea.selectionStart;
        const value = textarea.value;
        const lineStart = value.lastIndexOf("\n", start - 1) + 1;
        const linePrefix = value.substring(lineStart, start);
        if (linePrefix.startsWith("    ")) {
          textarea.value = value.substring(0, lineStart) + value.substring(lineStart + 4);
          textarea.selectionStart = textarea.selectionEnd = Math.max(lineStart, start - 4);
        }
        return;
      }

      // ===== Enter ?? ?ë¨®ë£ ?ã…¼ë¿¬?ê³Œë¦° + ï§¢ê¾©ì  ?â‘¥í…??=====
      // VSCode ?ã…½??? é®?ä»¥ê¾©ë¿‰???ë·€ê½£ = ?ã…¼ë¿¬?ê³Œë¦° ???â‘£í€ ç—â‘¥ëƒ¼
      if (e.key === "Enter") {
        // Shift+Enter: åª›ì’•í€ ï§¢ê¾©ì  (Mode3 ?ê¾©ìŠœ)
        if (e.shiftKey) {
          e.preventDefault();
          handleChallengeCheck(challengeNum);
          return;
        }

        // Ctrl+Enter???ê¾©ê»œ ï§¢ê¾©ì ?â‘¹ì‘æ¿¡??ê¾ªë™†
        if (e.ctrlKey || e.metaKey) {
          return;
        }

        e.preventDefault();
        const start = textarea.selectionStart;
        const value = textarea.value;
        const lineStart = value.lastIndexOf("\n", start - 1) + 1;
        const currentLine = value.substring(lineStart, start);

        // ?ê¾©ì˜± ä»¥ê¾©ì“½ ?ã…¼ë¿¬?ê³Œë¦° ç•°ë¶¿í…§
        const indentMatch = currentLine.match(/^(\s*)/);
        let indent = indentMatch ? indentMatch[1] : "";

        // ??VSCode ?ã…½??? ?ê¾©ì˜± ä»¥ê¾©ì”  æ€¨ë“¬ê°šï§??ë‰ì‘ï§?(é®?ä»¥? ?ã…¼ë¿¬?ê³Œë¦° ???â‘£í€ ç—â‘¥ëƒ¼
        if (currentLine.trim() === "" && indent.length >= 4) {
          // ?ëŒìŸ¾ ä»¥ê¾©ì“½ æ€¨ë“¬ê°š??4ç§»?ä»¥ê¾©ì” æ¹²?(?ã…¼ë¿¬?ê³Œë¦° ç—â‘¥ëƒ¼)
          const newIndent = indent.substring(4);
          // ?ê¾©ì˜± ä»¥??ëŒìŠœ?????ã…¼ë¿¬?ê³Œë¦°æ¿¡?æ´ë¨¯ê»œ
          textarea.value = value.substring(0, lineStart) + newIndent + "\n" + newIndent + value.substring(start);
          textarea.selectionStart = textarea.selectionEnd = lineStart + newIndent.length + 1 + newIndent.length;
          return;
        }

        // : æ¿¡??ì•¸êµ¹ï§?ç•°ë¶½? ?ã…¼ë¿¬?ê³Œë¦° (def, if, for, while, class, try, except ??
        if (currentLine.trim().endsWith(":")) {
          indent += "    ";
        }

        textarea.value = value.substring(0, start) + "\n" + indent + value.substring(start);
        textarea.selectionStart = textarea.selectionEnd = start + 1 + indent.length;
        return;
      }
    });

    cardDiv.appendChild(textarea);

    // è¸°ê¾ªë“‰ ?ê³¸ë¿­
    const btnDiv = document.createElement("div");
    btnDiv.className = "challenge-actions";

    const checkBtn = document.createElement("button");
    checkBtn.className = "challenge-check-btn";
    checkBtn.textContent = "??AI ï§¢ê¾©ì ";
    checkBtn.addEventListener("click", () => handleChallengeCheck(challengeNum));

    const showBtn = document.createElement("button");
    showBtn.className = "challenge-show-btn";
    showBtn.textContent = "?ëº£ë–Ÿ è¹‚ë‹¿ë¦°";
    showBtn.addEventListener("click", () => handleChallengeShow(challengeNum));

    const resetBtn = document.createElement("button");
    resetBtn.className = "challenge-reset-btn";
    resetBtn.textContent = "?ë´½ ?ã…¼ë–† ?Â€æ¹²?;
    resetBtn.addEventListener("click", () => handleChallengeReset(challengeNum));

    const helpBtn = document.createElement("button");
    helpBtn.className = "help-btn";
    helpBtn.textContent = "?";
    helpBtn.title = "AIåª›Â€ ?ëº£ë–Ÿæ€¨??ëŒì‘€ç‘œ?è‚„ë¶¾ë±¶?Â€ ?â‘£í¡ ?ã…»ì±¸?â‘¸ë•²??";
    helpBtn.addEventListener("click", () => explainBlank(String(challengeNum)));

    const whyWrongBtn = document.createElement("button");
    whyWrongBtn.className = "why-wrong-btn";
    whyWrongBtn.textContent = "?????Â€?ëªƒêµ¹??";
    whyWrongBtn.style.cssText = "background: linear-gradient(135deg, #ff6b6b, #ee5a5a); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;";
    whyWrongBtn.addEventListener("click", () => explainWhyWrong(challengeNum, 'challenge'));

    btnDiv.appendChild(checkBtn);
    btnDiv.appendChild(showBtn);
    btnDiv.appendChild(resetBtn);
    btnDiv.appendChild(helpBtn);
    btnDiv.appendChild(whyWrongBtn);
    cardDiv.appendChild(btnDiv);

    // å¯ƒê³Œë‚µ
    const resultDiv = document.createElement("div");
    resultDiv.className = "challenge-result";
    resultDiv.id = `challenge-result-${challengeNum}`;
    cardDiv.appendChild(resultDiv);

    frag.appendChild(cardDiv);

    challengeStates.push({
      challengeNum,
      signature: ch.signature,
      answer,
      answered: false,
      isCorrect: null,
      hasBeenWrong: false
    });
  });

  codeArea.appendChild(frag);
  renderChallengeNav();
  sessionCount.textContent = challenges.length;
  hasAnswers = true;
  updateChallengeScore();
}

async function handleChallengeCheck(num) {
  const card = document.getElementById(`challenge-${num}`);
  const textarea = card.querySelector("textarea");
  const state = challengeStates.find(s => s.challengeNum === num);
  const resultDiv = document.getElementById(`challenge-result-${num}`);

  const userAnswer = textarea.value.trim();

  // é®??ë“­ë¸ ï§£ëŒ„ê²•
  if (!userAnswer) {
    resultDiv.innerHTML = `<span class="mc-wrong">??è‚„ë¶¾ë±¶ç‘œ??ë‚…ì °?ëŒï¼œ?ëª„ìŠ‚</span>`;
    return;
  }

  // ?ëŒ€? ?ã…»ë–Ÿ?ì‡°ì¤ˆ ?ì’–ë–†???ê³¹ê¹­?ë¨¯ê½Œ ?ã…¼ë–† ?ëº¤ì”¤ è¸°ê¾ªë“‰ ???ëº£ë–Ÿ ?ì’–ë–†
  if (textarea.classList.contains("wrong") && !textarea.classList.contains("revealed")) {
    handleChallengeShow(num);
    return;
  }

  // ?ëŒ€? ï§¢ê¾©ì  ?ê¾¨ì¦º???ê³¹ê¹­ï§?è‡¾ëŒë–†
  if (textarea.classList.contains("correct") || textarea.classList.contains("revealed")) {
    return;
  }

  // AI ï§¢ê¾©ì  ?ì’–ì˜‰
  resultDiv.innerHTML = `<span class="definition-loading">?ëµ‡ è‚„ë¶¾ë±¶ é®ê¾§íƒ³ ä»¥?..</span>`;

  const expected = state.answer.trim();
  const signature = state.signature || "";

  try {
    // ?ê¾©ë¼±?ê³Œë¦°ï§?è‡¾ëŒë–†?ì„í€¬ ?ëº¥ì†—??é®ê¾§íƒ³ (AI ?ë†ì”  æ¿¡ì’–ëº„ é®ê¾§íƒ³)
    // - ï§â‘¤ë±º æ€¨ë“¬ê°š(?ã…½ëŸ¹?ëŒë’ª, ?? ä»¥ê¾¨ì»®è½…??ê³—ëƒ½)???â‘¥ì”ª æ€¨ë“¬ê°š?ì‡°ì¤ˆ
    // - äºŒì‡±ê½?Â€ ?ì’“êµ…
    // - ?ì„ã‰§ï§Â€???ëº¥ì†—???ì‡±íŠ‚?ëŒë¹ ??    const normalize = (s) => {
      // ä»¥ê¾¨ì»®è½…????Ñ‰ìœ­ æ€¨ë“¬ê°š ï§¡â‘¥ì” ç‘œ?ï§â‘¤ëª¢ ?â‰ªë‹”??é®ê¾§íƒ³?ì’•ë–.
      return s
        .replace(/\r\n?/g, "\n")            // CRLF ??LF
        .replace(/\t/g, "    ")            // ????æ€¨ë“¬ê°š 4ç§»?        .split("\n")
        .map(line => line.replace(/#.*$/, "").trim()) // äºŒì‡±ê½ ?ì’“êµ… + ?ë¬ê±¹ æ€¨ë“¬ê°š ?ì’“êµ…
        .filter(line => line.length)       // é®?ä»¥??ì’“êµ…
        .join("\n")
        .replace(/\s+/g, " ")              // ?ê³—ëƒ½ æ€¨ë“¬ê°š ?ì„êµ¹æ¿¡?        .trim();
    };

    const normalizedUser = normalize(userAnswer);
    const normalizedExpected = normalize(expected);
    const isCorrect = normalizedUser === normalizedExpected;

    let feedback = '';
    if (isCorrect) {
      feedback = '?ëº£ë–Ÿ?ë‚…ë•²?? è‚„ë¶¾ë±¶åª›Â€ ?ëº¥ì†—???ì‡±íŠ‚?â‘¸ë•²??';
    } else {
      // ?ëŒ€ëµ’åª›Â€ ?ã…»â…¨ï§Â€ ?ëš°ë“ƒ ?ì’“ë‚¬
      const userTokens = normalizedUser.split(' ');
      const expectedTokens = normalizedExpected.split(' ');
      let diffHint = '';
      for (let i = 0; i < Math.max(userTokens.length, expectedTokens.length); i++) {
        if (userTokens[i] !== expectedTokens[i]) {
          const yourPart = userTokens[i] || '(?ë†ì“¬)';
          const correctPart = expectedTokens[i] || '(?ë†ì“¬)';
          diffHint = `[${yourPart}] ??[${correctPart}]`;
          break;
        }
      }
      feedback = diffHint ? `ï§£?è¸°ë‰ã ï§¡â‘¥ì” : ${diffHint}` : 'è‚„ë¶¾ë±¶ ?ëŒìŠœ???ã…»ì«­?ëˆë–. è¹‚Â€?ì„ì±¸/?â‘¥ë‹”ï§ë‚†ì“£ ?ëº¤ì”¤?ì„ê½­??';
    }

    const result = { correct: isCorrect, feedback };

    finishChallengeCheck(num, result.correct, result.feedback);

  } catch (err) {
    // API ?ã…»ìªŸ ???â‘¥ë‹š é®ê¾§íƒ³æ¿¡??ëŒ€ê°š
    const normalize = (s) => s.replace(/\s+/g, ' ').replace(/\s*#.*$/gm, '').trim();
    const isCorrect = normalize(userAnswer) === normalize(expected);
    finishChallengeCheck(num, isCorrect, `${isCorrect ? "?ëº£ë–Ÿ!" : "?ã…¼ë–† ?ëº¤ì”¤?ëŒ€ë‚«?ëª„ìŠ‚"} (AI ?ã…»ìªŸ: ${err.message})`);
  }
}

function finishChallengeCheck(num, isCorrect, feedback) {
  const card = document.getElementById(`challenge-${num}`);
  const textarea = card.querySelector("textarea");
  const state = challengeStates.find(s => s.challengeNum === num);
  const resultDiv = document.getElementById(`challenge-result-${num}`);

  state.answered = true;
  state.isCorrect = isCorrect;
  textarea.classList.remove("wrong", "correct", "retried");

  if (isCorrect) {
    const wasWrongBefore = state.hasBeenWrong;
    if (wasWrongBefore) {
      textarea.classList.add("retried");
      challengeReviewQueue.add(String(num));
      resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ! (?Ñ‰ë£„???ê¹ƒë‚¬)</span>`;
    } else {
      textarea.classList.add("correct");
      challengeReviewQueue.delete(String(num));
      resultDiv.innerHTML = `<span class="mc-correct">??${feedback}</span>`;
    }
    SoundEffects.play("correct");
  } else {
    state.hasBeenWrong = true;
    textarea.classList.add("wrong");
    challengeReviewQueue.add(String(num));
    resultDiv.innerHTML = `<span class="mc-wrong">??${feedback}<br><small style="color: var(--muted);">?ã…¼ë–† ?ëº¤ì”¤ è¸°ê¾ªë“‰???ê¾¨â…¤ï§??ëº£ë–Ÿ??è¹‚????ë‰ë’¿?ëˆë–</small></span>`;
    SoundEffects.play("wrong");
  }

  const nav = document.getElementById(`nav-challenge-${num}`);
  if (nav) {
    nav.classList.remove("pending");
    nav.classList.remove("correct", "wrong", "retried");
    if (isCorrect) {
      nav.classList.add(state.hasBeenWrong ? "retried" : "correct");
    } else {
      nav.classList.add("wrong");
    }
  }

  LearningStats.recordAnswer(isCorrect);
  updateChallengeScore();
}

// ???Â€?ëªƒêµ¹?? AI ?ã…»ì±¸
async function explainWhyWrong(num, mode) {
  let userAnswer = '';
  let correctAnswer = '';
  let resultDiv = null;
  let question = '';

  if (mode === 'challenge') {
    const state = challengeStates.find(s => s.challengeNum === num);
    const textarea = document.getElementById(`challenge-${num}`)?.querySelector('textarea');
    userAnswer = textarea?.value || '';
    correctAnswer = state?.answer || '';
    resultDiv = document.getElementById(`challenge-result-${num}`);
    question = state?.signature || '';
  } else if (mode === 'vocab') {
    const state = vocabStates.find(s => s.wordNum === num);
    const textarea = document.getElementById(`vocab-input-${num}`);
    userAnswer = textarea?.value || '';
    correctAnswer = state?.correctAnswer || '';
    resultDiv = document.getElementById(`vocab-result-${num}`);
    question = state?.english || '';
  } else if (mode === 'definition') {
    const state = definitionStates.find(s => s.defNum === num);
    const textarea = document.getElementById(`def-input-${num}`);
    userAnswer = textarea?.value || '';
    correctAnswer = state?.correctAnswer || '';
    resultDiv = document.getElementById(`def-result-${num}`);
    question = state?.term || '';
  }

  if (!resultDiv) return;

  resultDiv.innerHTML = `<span style="color: var(--accent-2);">?ì¨º ï§¡â‘¥ì” ??éºê¾©ê½ ä»¥?..</span>`;

  const prompt = `?ÑŠìŠœ?ë¨­? ?ë‚…ì °???ë“¦ë‚µ ?ëº£ë–Ÿ??é®ê¾§íƒ³?ëŒê½Œ æ´ÑŠê»œ?ê³¸ì‘æ¿¡?è‡¾ëŒë¾¿???ã…»â…¨ï§Â€ ?ëš®ì ®äºŒì‡±ê½­??

## è‡¾ëª„ì £/ï§ëˆĞ¦
${question}

## ?ÑŠìŠœ???ë‚…ì °
\`\`\`
${userAnswer}
\`\`\`

## ?ëº£ë–Ÿ
\`\`\`
${correctAnswer}
\`\`\`

## ?ë¶¿ê»Œ
1. ???ë“­ì“½ ï§¡â‘¥ì” ?ë¨¯ì“£ æ´ÑŠê»œ?ê³¸ì‘æ¿¡?ï§Â€??2. ?ëŒ€ë¼¡ éºÂ€éºê¾©ì”  ?Â€?ëªƒë’—ï§Â€ ï§ë‚‡ì†—?ì„ì¾¶ ?ã…»ì±¸
3. 2-3ä»¥??ëŒ€ê¶¡æ¿¡?åª›ê¾§ê»?ì„ì¾¶`;

  try {
    const response = await callGeminiAPI(prompt, "ï§¡â‘¥ì” ?ë¨¯ì“£ æ´ÑŠê»œ?ê³¸ì” æ€¨?åª›ê¾§ê»?ì„ì¾¶ ?ã…»ì±¸?ì„ê½­??");
    resultDiv.innerHTML = `
      <div style="background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 8px; padding: 12px; margin-top: 8px;">
        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 6px;">?????Â€?ëªƒêµ¹??</div>
        <div style="color: var(--fg);">${escapeHtml(response)}</div>
      </div>`;
  } catch (err) {
    resultDiv.innerHTML = `<span class="mc-wrong">??éºê¾©ê½ ?ã…»ìªŸ: ${err.message}</span>`;
  }
}

function handleChallengeShow(num) {
  const card = document.getElementById(`challenge-${num}`);
  const textarea = card.querySelector("textarea");
  const state = challengeStates.find(s => s.challengeNum === num);

  textarea.value = state.answer;
  textarea.disabled = true;
  textarea.classList.remove("wrong");
  textarea.classList.add("revealed");

  state.answered = true;
  state.isCorrect = false;

  const resultDiv = document.getElementById(`challenge-result-${num}`);
  resultDiv.innerHTML = `<span class="mc-wrong">?ëº£ë–Ÿ???ì’–ë–†?ì„ë¿€?ë“¬ë•²??/span>`;

  const nav = document.getElementById(`nav-challenge-${num}`);
  if (nav) {
    nav.classList.remove("pending", "wrong");
    nav.classList.add("revealed");
  }

  updateChallengeScore();
}

function handleChallengeReset(num) {
  const card = document.getElementById(`challenge-${num}`);
  const textarea = card.querySelector("textarea");
  const state = challengeStates.find(s => s.challengeNum === num);

  // ?ê³¹ê¹­ ç”±ÑŠë€‘
  textarea.value = "";
  textarea.disabled = false;
  textarea.classList.remove("correct", "wrong", "revealed", "retried");
  textarea.focus();

  state.answered = false;
  state.isCorrect = null;
  state.hasBeenWrong = false;
  challengeReviewQueue.delete(String(num));

  // å¯ƒê³Œë‚µ ç¥ë‡ë¦°??  const resultDiv = document.getElementById(`challenge-result-${num}`);
  resultDiv.innerHTML = "";

  // ?ã…»í‰¬å¯ƒëš¯ì” ??ç¥ë‡ë¦°??  const nav = document.getElementById(`nav-challenge-${num}`);
  if (nav) {
    nav.classList.remove("correct", "wrong", "revealed", "retried");
    nav.classList.add("pending");
  }

  updateChallengeScore();
}

function renderChallengeNav() {
  blankList.innerHTML = "";
  challengeStates.forEach((s) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-challenge-${s.challengeNum}`;
    btn.textContent = `C${s.challengeNum}`;
    btn.addEventListener("click", () => {
      const target = document.getElementById(`challenge-${s.challengeNum}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
    });
    blankList.appendChild(btn);
  });
  applyNavFilter();
}

function updateChallengeScore() {
  const total = challengeStates.length;
  const correct = challengeStates.filter(s => s.isCorrect).length;
  const answered = challengeStates.filter(s => s.answered).length;
  const retried = challengeStates.filter(s => s.isCorrect && s.hasBeenWrong).length;
  const wrong = challengeStates.filter(s => s.answered && !s.isCorrect).length;

  sessionScore.textContent = `${correct} / ${total}`;
  const ratio = total ? (correct / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    const reviewCount = wrong + retried;
    if (reviewCount) {
      reviewBadge.textContent = `è¹‚ë“­ë’¿ ${reviewCount}åª›?;
    } else if (answered === total) {
      reviewBadge.textContent = `?ê¾¨ì¦º! ${correct}/${total}`;
    } else {
      reviewBadge.textContent = `ï§ê¾ªë»¾ ä»¥?${answered}/${total}`;
    }
  }
  applyNavFilter();
}

function renderBlankNav() {
  blankList.innerHTML = "";
  inputs.forEach((inp) => {
    const key = inp.dataset.key;
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-${key}`;
    btn.textContent = `#${key}`;
    btn.addEventListener("click", () => {
      const target = document.getElementById(`blank-${key}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
      inp.focus();
    });
    blankList.appendChild(btn);
  });
  applyNavFilter();
}

function applyNavFilter() {
  const pills = document.querySelectorAll("#blank-list .blank-pill");
  pills.forEach((pill) => {
    const isDone =
      pill.classList.contains("correct") ||
      pill.classList.contains("revealed") ||
      pill.classList.contains("retried");
    pill.style.display = hideCompletedNav && isDone ? "none" : "";
  });
}

function checkOne(input) {
  const expected = input.dataset.answer;
  if (expected === undefined) return null;
  if (input.dataset.revealed === "true") {
    setState(input, "revealed");
    return false;
  }
  const user = input.value.trim();
  const key = input.dataset.key;
  const isCorrect = user === expected.trim();
  if (!user) {
    setState(input, "pending");
  } else {
    setState(input, isCorrect ? "correct" : "wrong");
  }
  toggleReview(key, !isCorrect && !!user);
  updateScore();
  return isCorrect;
}

function checkAll() {
  // Mode 7 (?ê³·ë–’?? ï§£ì„â”
  if (vocabStates && vocabStates.length > 0) {
    const unansweredIndices = vocabStates
      .filter(s => !s.answered && !s.needsAi)
      .map(s => s.wordNum);

    if (unansweredIndices.length === 0) {
      alert('ï§â‘¤ë±º ?ê³·ë–’?ë‹¿? ?ëŒ€? ï§¢ê¾©ì ?ì„ë¿€?ë“¬ë•²??');
      return;
    }

    unansweredIndices.forEach(num => handleVocabCheck(num));
    return;
  }

  // Mode 5 (?ëº¤ì“½ ?ëŒì«°) ï§£ì„â”
  if (definitionStates && definitionStates.length > 0) {
    const unansweredIndices = definitionStates
      .filter(s => !s.answered)
      .map(s => s.defNum);

    if (unansweredIndices.length === 0) {
      alert('ï§â‘¤ë±º ?ëº¤ì“½åª›Â€ ?ëŒ€? ï§¢ê¾©ì ?ì„ë¿€?ë“¬ë•²??');
      return;
    }

    // ?ì’–ê°?ê³¸ì‘æ¿¡?åª›??ëº¤ì“½ ï§¢ê¾©ì  (AI ?ÑŠìŠœ ??
    const checkNextDef = async (indices) => {
      if (indices.length === 0) {
        updateDefinitionScore();
        return;
      }
      const num = indices[0];
      await handleDefinitionCheck(num);
      setTimeout(() => checkNextDef(indices.slice(1)), 300);
    };

    checkNextDef(unansweredIndices);
    return;
  }

  // Mode 3 (è«›ê¹†?è¹‚ë“­ë’¿ / ï§¢ëš®â”›ï§Â€ ï§â‘¤ë±¶) ï§£ì„â”
  if (challengeStates.length > 0) {
    const unansweredIndices = challengeStates
      .filter(s => !s.answered)
      .map(s => s.challengeNum);

    if (unansweredIndices.length === 0) {
      alert('ï§â‘¤ë±º ï§¢ëš®â”›ï§Â€åª›Â€ ?ëŒ€? ï§¢ê¾©ì ?ì„ë¿€?ë“¬ë•²??');
      return;
    }

    // ?ì’–ê°?ê³¸ì‘æ¿¡?åª›?ï§¢ëš®â”›ï§Â€ ï§¢ê¾©ì  ?ì’–ì˜‰
    const checkNextChallenge = async (indices) => {
      if (indices.length === 0) {
        updateChallengeScore();
        return;
      }
      const num = indices[0];
      await handleChallengeCheck(num);
      // ?ì„ì»™???ì’•ì …?????ã…¼ì“¬ ï§¢ê¾©ì  (API æ€¨ì‡°???è«›â‘¹?)
      setTimeout(() => checkNextChallenge(indices.slice(1)), 500);
    };

    checkNextChallenge(unansweredIndices);
    return;
  }

  // ?ì‡°ì»² é®ë‰ë­ ï§â‘¤ë±¶
  inputs.forEach((input) => checkOne(input));
}

function revealAll() {
  inputs.forEach((input) => revealOne(input, { autoAdvance: false }));
  updateScore();
}

function resetInputs() {
  inputs.forEach((input) => {
    input.value = "";
    delete input.dataset.revealed;
    setState(input, "pending");
  });
  reviewQueue = new Set();
  updateScore();
}

function updateScore() {
  if (!hasAnswers) {
    sessionScore.textContent = "?ëº£ë–Ÿ ???ë†ì“¬";
    sessionProgress.style.width = "0%";
    if (reviewBadge) reviewBadge.textContent = "?ëº£ë–Ÿ ???ë†ì“¬";
    return;
  }
  let correct = 0;
  let revealed = 0;
  inputs.forEach((input) => {
    if (input.classList.contains("correct") || input.classList.contains("retried")) correct += 1;
    if (input.classList.contains("revealed")) revealed += 1;
  });
  sessionScore.textContent =
    `${correct} / ${inputs.length}` +
    (reviewQueue.size ? ` (è¹‚ë“­ë’¿ ${reviewQueue.size})` : revealed ? ` (?ëº£ë–Ÿ ?ì’–ë–† ${revealed})` : "");
  const ratio = inputs.length ? (correct / inputs.length) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;
  if (reviewBadge) {
    const pending = Math.max(inputs.length - correct - revealed, 0);
    if (reviewQueue.size) {
      reviewBadge.textContent = `è¹‚ë“­ë’¿ ${reviewQueue.size}åª›?;
    } else if (pending > 0) {
      reviewBadge.textContent = `èª˜ëª„ì½ˆ??${pending}åª›?;
    } else {
      reviewBadge.textContent = "ï§â‘¤ë±º é®ë‰ë­ ?ê¾¨ì¦º";
    }
  }
  applyNavFilter();
}

function focusNext(current) {
  const idx = inputs.indexOf(current);
  const next = inputs[idx + 1];
  if (next) next.focus();
}

function setState(input, state, { preserveReview = false } = {}) {
  input.classList.remove("correct", "wrong", "revealed", "retried");
  const nav = document.getElementById(`nav-${input.dataset.key}`);
  nav && nav.classList.remove("pending", "correct", "wrong", "revealed", "retried");
  const key = input.dataset.key;
  if (state !== "revealed") delete input.dataset.revealed;
  switch (state) {
    case "correct":
      if (input.dataset.hasBeenWrong === "true") {
        input.classList.add("retried");
        nav && nav.classList.add("retried");
        if (!preserveReview) toggleReview(key, true);
      } else {
        input.classList.add("correct");
        nav && nav.classList.add("correct");
        if (!preserveReview) toggleReview(key, false);
      }
      break;
    case "wrong":
      input.dataset.hasBeenWrong = "true";
      input.classList.add("wrong");
      nav && nav.classList.add("wrong");
      if (!preserveReview) toggleReview(key, true);
      break;
    case "revealed":
      input.dataset.revealed = "true";
      input.dataset.hasBeenWrong = "true";
      input.classList.add("revealed");
      nav && nav.classList.add("revealed");
      if (!preserveReview) toggleReview(key, true);
      break;
    default:
      delete input.dataset.hasBeenWrong;
      nav && nav.classList.add("pending");
      if (!preserveReview) toggleReview(key, false);
  }
}

function toggleReview(key, shouldAdd) {
  if (!key) return;
  if (shouldAdd) reviewQueue.add(String(key));
  else reviewQueue.delete(String(key));
}

function revealOne(input, { autoAdvance = true } = {}) {
  const expected = input.dataset.answer;
  if (expected === undefined) return;
  const userCorrect = input.value.trim() === expected.trim();
  const alreadyRevealed = input.dataset.revealed === "true";
  if (alreadyRevealed) {
    setState(input, "revealed");
  } else if (!userCorrect) {
    input.value = expected;
    setState(input, "revealed");
  } else {
    setState(input, "correct");
  }
  updateScore();
  if (autoAdvance) focusNext(input);
}

function handleEnter(input) {
  // 2?â‘£í€ ï§¢ê¾©ì  ?ì’–ë’ª??
  // 1?â‘£í€: ?ëº£ë–Ÿ/?ã…»ë–Ÿ ?ì’–ë–†ï§?  // 2?â‘£í€: ?ã…»ë–Ÿ??å¯ƒìŒìŠ¦ ?ëº£ë–Ÿ ?ì’–ë–† (?ëªƒ???

  // ?ëŒ€? ?ã…»ë–Ÿ?ì‡°ì¤ˆ ?ì’–ë–†???ê³¹ê¹­?ë¨¯ê½Œ ?ã…¼ë–† Enterç‘œ??ê¾¨â…¤ï§??ëº£ë–Ÿ ?ì’–ë–†
  if (input.classList.contains("wrong") && !input.classList.contains("revealed")) {
    // 2?â‘£í€: ?ëº£ë–Ÿ ?ì’–ë–† (?ëªƒ???
    revealOne(input, { autoAdvance: true });
    return;
  }

  // ?ëŒ€? ï§¢ê¾©ì  ?ê¾¨ì¦º???ê³¹ê¹­ï§??ã…¼ì“¬?ì‡°ì¤ˆ ?ëŒ€ë£
  if (input.classList.contains("correct") || input.classList.contains("revealed")) {
    focusNext(input);
    return;
  }

  // 1?â‘£í€: ï§¢ê¾©ì ï§??ì„‘ë»¾
  const ok = checkOne(input);
  if (ok === null) {
    if (!warnedMissingAnswers && !hasAnswers) {
      alert(missingAnswerMessage);
      warnedMissingAnswers = true;
    }
    return;
  }

  if (!ok) {
    // ?ã…»ë–Ÿ: é®â‘£ì»™?ë°ì­” ?ì’–ë–† (?ëº£ë–Ÿ?Â€ ?ê¾©ì­… ?ì’–ë–† ????
    setState(input, "wrong");
    SoundEffects.play("wrong");
    LearningStats.recordAnswer(false);
    updateScore();
    // ?ã…¼ì“¬ Enterç‘œ?æ¹²ê³•ë–ç”±?(?ë¨®ë£ ?ëº£ë–Ÿ ?ì’–ë–† ?ì’“êµ…)
  } else {
    // ?ëº£ë–Ÿ
    SoundEffects.play("correct");
    LearningStats.recordAnswer(true);
    focusNext(input);
  }
}

function startReviewCycle() {
  // 4è¸°?ï§â‘¤ë±¶(?ëš¯ë–›??åª›ì•·????â‘¤ë–Ÿ) ?ê³—ê½‘ ï§£ì„â”
  if (parsedQuizStates.length > 0) {
    const reviewTargets = parsedQuizStates.filter(
      (s) => s.isCorrect === false || s.isCorrect === null || !s.answered
    );

    if (!reviewTargets.length) {
      alert("è¹‚ë“­ë’¿??è‡¾ëª„ì £åª›Â€ ?ë†ë’¿?ëˆë–. ç™’ì‡±? ?Â€ç”±?è‡¾ëª„ì £??èª˜ëª„ì“³??è‡¾ëª„ì £ç‘œ?ï§ëš®ë±¾?ëŒï¼œ?ëª„ìŠ‚.");
      return;
    }

    // ??ç¥ë‡ë¦°?????Â€??ç•°ë¶½?
    reviewQueue = new Set(reviewTargets.map((s) => String(s.qId)));

    // UI/?ê³¹ê¹­ ç”±ÑŠë€‘ + é®ê¾¨???ç§»ëŒ€ë±¶ ?â‘£?
    parsedQuizStates.forEach((s) => {
      const isTarget = reviewQueue.has(String(s.qId));
      const card = document.getElementById(`pq-${s.qId}`);
      if (card) {
        card.style.display = isTarget ? "" : "none";
        card.querySelectorAll(".mc-option").forEach((opt) => {
          opt.disabled = !isTarget;
          opt.classList.remove("correct", "wrong", "selected");
        });
        const textarea = card.querySelector("textarea");
        if (textarea) {
          textarea.disabled = !isTarget;
          if (isTarget) {
            textarea.value = "";
            textarea.style.background = "rgba(255,255,255,0.05)";
            textarea.style.borderColor = "rgba(255,255,255,0.1)";
          }
        }
        const resultDiv = document.getElementById(`pq-result-${s.qId}`);
        if (resultDiv && isTarget) resultDiv.innerHTML = "";
      }
      const nav = document.getElementById(`nav-pq-${s.qId}`);
      if (nav) {
        nav.style.display = isTarget ? "" : "none";
        nav.classList.remove("correct", "wrong", "revealed");
        if (isTarget) nav.classList.add("pending");
      }
      if (isTarget) {
        s.answered = false;
        s.isCorrect = null;
        s.selected = null;
      }
    });

    updateParsedQuizScore();
    focusNextReview();
    return;
  }

  // Mode 3 ï§¢ëš®â”›ï§Â€ (è«›ê¹†? ?ê³—ë’¿)
  if (challengeStates.length > 0) {
    const reviewTargets = challengeStates.filter(
      (s) => s.isCorrect === false || !s.answered || s.hasBeenWrong
    );
    if (!reviewTargets.length) {
      alert("è¹‚ë“­ë’¿??è‡¾ëª„ì £åª›Â€ ?ë†ë’¿?ëˆë–. ç™’ì‡±? ?Â€ç”±?è‡¾ëª„ì £??èª˜ëª„ì“³??è‡¾ëª„ì £ç‘œ?ï§ëš®ë±¾?ëŒï¼œ?ëª„ìŠ‚.");
      return;
    }
    reviewQueue = new Set(reviewTargets.map((s) => String(s.challengeNum)));
    challengeStates.forEach((s) => {
      const isTarget = reviewQueue.has(String(s.challengeNum));
      const card = document.getElementById(`challenge-${s.challengeNum}`);
      if (card) {
        card.style.display = isTarget ? "" : "none";
        const textarea = card.querySelector("textarea");
        const resultDiv = document.getElementById(`challenge-result-${s.challengeNum}`);
        if (textarea) {
          textarea.disabled = !isTarget;
          if (isTarget) {
            textarea.value = "";
            textarea.classList.remove("correct", "wrong", "revealed", "retried");
            if (resultDiv) resultDiv.innerHTML = "";
          }
        }
      }
      const nav = document.getElementById(`nav-challenge-${s.challengeNum}`);
      if (nav) {
        nav.style.display = isTarget ? "" : "none";
        nav.classList.remove("correct", "wrong", "retried", "revealed");
        if (isTarget) nav.classList.add("pending");
      }
      if (isTarget) {
        s.answered = false;
        s.isCorrect = null;
        s.hasBeenWrong = false;
      }
    });
    updateChallengeScore();
    focusNextReview();
    return;
  }

  // ?ëº¤ì“½ ?ëŒì«° / ?ê³·ë–’??ç§»ëŒ€ë±¶
  if (definitionStates.length > 0 || vocabStates.length > 0) {
    const defTargets = definitionStates.filter((s) => s.isCorrect === false || !s.answered);
    const vocabTargets = vocabStates.filter((s) => s.isCorrect === false || !s.answered);
    if (!defTargets.length && !vocabTargets.length) {
      alert("è¹‚ë“­ë’¿??ç§»ëŒ€ë±¶åª›Â€ ?ë†ë’¿?ëˆë–.");
      return;
    }
    reviewQueue = new Set([
      ...defTargets.map((s) => `definition-${s.defNum}`),
      ...vocabTargets.map((s) => `vocab-${s.wordNum}`)
    ]);

    // ?ëº¤ì“½ ç§»ëŒ€ë±¶
    definitionStates.forEach((s) => {
      const isTarget = reviewQueue.has(`definition-${s.defNum}`);
      const card = document.getElementById(`definition-${s.defNum}`);
      if (card) {
        card.style.display = isTarget ? "" : "none";
        const textarea = document.getElementById(`def-input-${s.defNum}`);
        const resultDiv = document.getElementById(`def-result-${s.defNum}`);
        if (textarea) {
          textarea.disabled = !isTarget;
          if (isTarget) {
            textarea.value = "";
            textarea.classList.remove("correct", "wrong", "revealed", "retried");
            if (resultDiv) resultDiv.innerHTML = "";
          }
        }
      }
    });

    // ?ê³·ë–’??ç§»ëŒ€ë±¶
    vocabStates.forEach((s) => {
      const isTarget = reviewQueue.has(`vocab-${s.wordNum}`);
      const card = document.getElementById(`vocab-${s.wordNum}`);
      if (card) {
        card.style.display = isTarget ? "" : "none";
        const textarea = document.getElementById(`vocab-input-${s.wordNum}`);
        const resultDiv = document.getElementById(`vocab-result-${s.wordNum}`);
        if (textarea) {
          textarea.disabled = !isTarget;
          if (isTarget) {
            textarea.value = "";
            textarea.classList.remove("correct", "wrong", "revealed", "retried");
            if (resultDiv) resultDiv.innerHTML = "";
          }
        }
      }
    });

    updateDefinitionScore();
    updateVocabScore();
    focusNextReview();
    return;
  }

  // ?ì‡°ì»² é®ë‰ë­ ï§â‘¤ë±¶
  const targets = inputs.filter(
    (inp) =>
      inp.classList.contains("wrong") ||
      inp.classList.contains("revealed") ||
      inp.classList.contains("retried")
  );
  if (!targets.length && !reviewQueue.size) {
    alert("è¹‚ë“­ë’¿??é®ë‰ë­???ë†ë’¿?ëˆë–. ç™’ì‡±? ï§¢ê¾©ì /?ëº£ë–Ÿ???ëº¤ì”¤?ëŒï¼œ?ëª„ìŠ‚.");
    return;
  }
  reviewQueue = new Set(reviewQueue);
  targets.forEach((inp) => {
    reviewQueue.add(inp.dataset.key);
  });
  // ?Â€????é®ë‰ë­?Â€ é®ê¾ªì†¢???â‘£?, ?Â€?ê³¸? ç”±ÑŠë€‘
  inputs.forEach((inp) => {
    const isTarget = reviewQueue.has(inp.dataset.key);
    const nav = document.getElementById(`nav-${inp.dataset.key}`) || document.getElementById(`nav-blank-${inp.dataset.key}`);
    if (isTarget) {
      inp.value = "";
      inp.disabled = false;
      setState(inp, "pending", { preserveReview: true });
      inp.style.opacity = "1";
      if (nav) nav.style.display = "";
    } else {
      inp.disabled = true;
      inp.style.opacity = "0.3";
      if (nav) nav.style.display = "none";
    }
  });
  updateScore();
  focusNextReview();
}

function focusNextReview() {
  if (parsedQuizStates.length > 0) {
    if (!reviewQueue.size) {
      alert("è¹‚ë“­ë’¿ ?ë¨­? é®ê¾©ë¼± ?ë‰ë’¿?ëˆë–.");
      return;
    }
    const [qId] = reviewQueue;
    const card = document.getElementById(`pq-${qId}`);
    const textarea = card?.querySelector("textarea");
    const option = card?.querySelector(".mc-option");

    if (card) {
      card.scrollIntoView({ behavior: "smooth", block: "center" });
      if (textarea) {
        textarea.focus();
        textarea.select();
      } else if (option) {
        option.focus();
      }
    }
    return;
  }

  if (challengeStates.length > 0) {
    if (!reviewQueue.size) {
      alert("è¹‚ë“­ë’¿ ?ë¨­? é®ê¾©ë¼± ?ë‰ë’¿?ëˆë–.");
      return;
    }
    const [id] = reviewQueue;
    const card = document.getElementById(`challenge-${id}`);
    const textarea = card?.querySelector("textarea");
    if (card) {
      card.scrollIntoView({ behavior: "smooth", block: "center" });
      if (textarea) {
        textarea.focus();
        textarea.select();
      }
    }
    return;
  }

  if (definitionStates.length > 0 || vocabStates.length > 0) {
    if (!reviewQueue.size) {
      alert("è¹‚ë“­ë’¿ ?ë¨­? é®ê¾©ë¼± ?ë‰ë’¿?ëˆë–.");
      return;
    }
    const [key] = reviewQueue;
    let card = null;
    if (key.startsWith("definition-")) {
      card = document.getElementById(key);
    } else if (key.startsWith("vocab-")) {
      card = document.getElementById(key);
    }
    const textarea = card?.querySelector("textarea");
    if (card) {
      card.scrollIntoView({ behavior: "smooth", block: "center" });
      if (textarea) {
        textarea.focus();
        textarea.select();
      }
    }
    return;
  }

  if (!reviewQueue.size) {
    alert("è¹‚ë“­ë’¿ ?ë¨­? é®ê¾©ë¼± ?ë‰ë’¿?ëˆë–.");
    return;
  }
  const [key] = reviewQueue;
  const target = document.getElementById(`blank-${key}`);
  const input = inputs.find((inp) => inp.dataset.key === key);
  if (target && input) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    input.focus();
    input.select();
  }
}

function highlightAnswer(language) {
  if (!answerBlock) return;
  answerBlock.className = `answer-block language-${language || "plaintext"}`;
  if (window.hljs) {
    window.hljs.highlightElement(answerBlock);
  }
}

// ========== BUTTON EVENT HANDLERS ==========
// DOMContentLoaded ?Â€??ï§ë±ë–† ?ã…½ë»¾ ?â‘¥ë‹”æ¿¡?è¹‚Â€å¯ƒ?(?ìˆˆìŸ» ?ã…½ê²•ç”±ì€ë“ƒ æ¿¡ì’•ë±¶ ?Â€??
function initializeButtonHandlers() {
  // ?ëªƒë±¶???ë¬’ëƒ½ äºŒì‡±ëƒ¼ è«›?ngrok URL æ¿¡ì’•ë±¶ è«›??ì’–ë–†
  const mobileUrlEl = document.getElementById("mobile-url");
  const ngrokUrlEl = document.getElementById("ngrok-url");

  // server_info.json?ë¨¯ê½Œ IP è«›?ngrok URL æ¿¡ì’•ë±¶
  fetch("/server_info.json")
    .then(r => r.json())
    .then(info => {
      const currentPort = window.location.port || "8000";

      // ï§â‘¤ì»®??URL ?ì’–ë–†
      if (mobileUrlEl) {
        const mobileUrl = `http://${info.local_ip}:${currentPort}`;
        mobileUrlEl.textContent = `?ë²‘ ${mobileUrl}`;
        mobileUrlEl.title = "?ëŒ€â”ƒ?ì„ãˆƒ è¹‚ë“­ê¶—";
      }

      // ngrok URL ?ì’–ë–† (?ëˆë’— å¯ƒìŒìŠ¦?ë¨®ì­”)
      if (ngrokUrlEl && info.ngrok_url) {
        ngrokUrlEl.textContent = `?ë™‹ ${info.ngrok_url}`;
        ngrokUrlEl.title = "?ëŒ€â”ƒ?ì„ãˆƒ è¹‚ë“­ê¶— (?ëªƒ? ?ë¬’ëƒ½??";
        ngrokUrlEl.style.display = "inline-block";

        // ?ëŒ€â”ƒ?ì„ãˆƒ è¹‚ë“­ê¶—
        ngrokUrlEl.addEventListener("click", () => {
          navigator.clipboard.writeText(info.ngrok_url).then(() => {
            const original = ngrokUrlEl.textContent;
            ngrokUrlEl.textContent = "??è¹‚ë“­ê¶—??";
            ngrokUrlEl.classList.add("copied");
            setTimeout(() => {
              ngrokUrlEl.textContent = original;
              ngrokUrlEl.classList.remove("copied");
            }, 1500);
          });
        });
      }
    })
    .catch(() => {
      // server_info.json ?ë†ì‘ï§??ê¾©ì˜± ?ëª„ë’ª???ÑŠìŠœ
      if (mobileUrlEl) {
        const currentHost = window.location.hostname;
        const currentPort = window.location.port || "8000";
        if (currentHost === "localhost" || currentHost === "127.0.0.1") {
          mobileUrlEl.textContent = "?ë²‘ åª›ìˆˆ? WiFi?ë¨¯ê½Œ PC IP:8000";
        } else {
          mobileUrlEl.textContent = `?ë²‘ http://${currentHost}:${currentPort}`;
        }
      }
    });

  // ï§â‘¤ì»®??URL ?ëŒ€â”ƒ?ì„ãˆƒ è¹‚ë“­ê¶—
  if (mobileUrlEl) {
    mobileUrlEl.addEventListener("click", () => {
      const url = mobileUrlEl.textContent.replace("?ë²‘ ", "");
      navigator.clipboard.writeText(url).then(() => {
        const original = mobileUrlEl.textContent;
        mobileUrlEl.textContent = "??è¹‚ë“­ê¶—??";
        mobileUrlEl.classList.add("copied");
        setTimeout(() => {
          mobileUrlEl.textContent = original;
          mobileUrlEl.classList.remove("copied");
        }, 1500);
      });
    });
  }

  // ?ê¾©ê»œ ï§¢ê¾©ì 
  const btnCheckLocal = document.getElementById("btn-check");
  if (btnCheckLocal) {
    btnCheckLocal.addEventListener("click", () => {
      // parsed_quiz ï§â‘¤ë±¶
      if (parsedQuizStates.length > 0) {
        const answered = parsedQuizStates.filter(s => s.answered).length;
        const total = parsedQuizStates.length;
        alert(`?ë±¤ ?ê¾©ì˜± ï§ê¾ªë»¾ ?ê³¹ì†´\n\n?ê¾¨ì¦º: ${answered} / ${total}åª›?n?â‘¥? è‡¾ëª„ì £: ${total - answered}åª›?n\n???ëš¯ë–›??è‡¾ëª„ì £???ëº£ë–Ÿ???????ë†ë¼± ï§¢ê¾©ì ??éºë‡??â‘¸ë•²??`);
        return;
      }
      // ?ì‡°ì»² é®ë‰ë­ ï§¢ê¾©ì 
      inputs.forEach((inp) => checkOne(inp, false));
      updateScore();
    });
  }

  // ?ê¾©ê»œ ?ëº£ë–Ÿ è¹‚ë‹¿ë¦°
  const btnRevealLocal = document.getElementById("btn-reveal");
  if (btnRevealLocal) {
    btnRevealLocal.addEventListener("click", () => {
      // parsed_quiz ï§â‘¤ë±¶
      if (parsedQuizStates.length > 0) {
        // ï§â‘¤ë±º è‡¾ëª„ì £??"?ì¢ê¹®?? ?ì’–ë–†ï§??ì’–ë–† (?ëº£ë–Ÿ??ï§â‘¤â…¤èª˜Â€æ¿¡?
        parsedQuizStates.forEach(s => {
          if (!s.answered) {
            const resultDiv = document.getElementById(`pq-result-${s.qId}`);
            if (resultDiv) {
              resultDiv.innerHTML = `<span style="color: var(--yellow);">?ì¢‘íˆ˜ èª˜ëª„ì“³??/span>`;
            }
            const nav = document.getElementById(`nav-pq-${s.qId}`);
            if (nav) {
              nav.classList.add("revealed");
            }
          }
        });
        alert("?ë±´ ?ëš¯ë–›??è‡¾ëª„ì £?ë¨®ë’— ?ëº£ë–Ÿ ?ëº£ë‚«åª›Â€ ?Ñ‹ë¸¿?ì„ë¼± ?ë‰? ?ë”†ë’¿?ëˆë–.\n\nPython è‚„ë¶¾ë±¶ ?ëš¯ì”ªæ¿¡??ëª„ë€¡???ì•¹ê½¦?ì„ãˆƒ ?ë¨®ë£ ï§¢ê¾©ì ??åª›Â€?Î½ë¹€?ëˆë–.");
        return;
      }
      // ?ì‡°ì»² é®ë‰ë­
      inputs.forEach((inp) => revealOne(inp));
      updateScore();
    });
  }

  // è¹‚ë“­ë’¿ ï§â‘¤ë±¶ ?ì’–ì˜‰
  const btnReview = document.getElementById("btn-review");
  if (btnReview) {
    btnReview.addEventListener("click", startReviewCycle);
  }

  // ç”±ÑŠë€‘
  const btnReset = document.getElementById("btn-reset");
  if (btnReset) {
    btnReset.addEventListener("click", () => {
      if (confirm("ï§â‘¤ë±º ?ë“¬???ç¥ë‡ë¦°?ë·€ë¸¯?ì’“ì¿‹?ë“¬ë•²æº?")) {
        // parsed_quiz ï§â‘¤ë±¶
        if (parsedQuizStates.length > 0) {
          parsedQuizStates.forEach(s => {
            s.answered = false;
            s.selected = null;
            s.userAnswer = "";

            // UI ç¥ë‡ë¦°??            const cardDiv = document.getElementById(`pq-${s.qId}`);
            if (cardDiv) {
              cardDiv.querySelectorAll(".mc-option").forEach(opt => {
                opt.disabled = false;
                opt.classList.remove("selected", "correct", "wrong");
              });
              const textarea = cardDiv.querySelector("textarea");
              if (textarea) {
                textarea.disabled = false;
                textarea.value = "";
                textarea.style.background = "rgba(255,255,255,0.05)";
                textarea.style.borderColor = "rgba(255,255,255,0.1)";
              }
            }
            const resultDiv = document.getElementById(`pq-result-${s.qId}`);
            if (resultDiv) resultDiv.innerHTML = "";

            const nav = document.getElementById(`nav-pq-${s.qId}`);
            if (nav) {
              nav.classList.remove("correct", "wrong", "revealed");
              nav.classList.add("pending");
            }
          });
          updateParsedQuizScore();
          return;
        }
        // ?ì‡°ì»² é®ë‰ë­
        inputs.forEach((inp) => {
          inp.value = "";
          setState(inp, "pending");
        });
        reviewQueue.clear();
        updateScore();
      }
    });
  }

  // API ??è¸°ê¾ªë“‰??  const btnApiKey = document.getElementById("btn-api-key");
  if (btnApiKey) {
    btnApiKey.addEventListener("click", showApiKeyModal);
  }

  const btnSaveApiKey = document.getElementById("btn-save-api-key");
  if (btnSaveApiKey) {
    btnSaveApiKey.addEventListener("click", () => {
      const key = document.getElementById("api-key-input").value.trim();
      if (key) {
        setApiKey(key);
        hideApiKeyModal();
        alert("API ?ã…º? ?Â€?Î»ë¦º?ë‰ë’¿?ëˆë–.");
      }
    });
  }

  const btnCancelApiKey = document.getElementById("btn-cancel-api-key");
  if (btnCancelApiKey) {
    btnCancelApiKey.addEventListener("click", hideApiKeyModal);
  }

  // ?ã…»ë‚«???â‘¥í…??è¸°ê¾ªë“‰
  const btnShortcuts = document.getElementById("btn-shortcuts");
  if (btnShortcuts) {
    btnShortcuts.addEventListener("click", () => KeyboardShortcuts.showHelp());
  }

  // ï§??ê¾¨ì¤ˆ è¸°ê¾ªë“‰
  const btnScrollTop = document.getElementById("btn-scroll-top");
  if (btnScrollTop) {
    btnScrollTop.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
  }

  // ?ìˆˆë’¿ ?Â€?ëŒ€ã‰§ ?ì’–ì˜‰ (?ëª„ë€¡ æ¿¡ì’•ë±¶???ëš®ë£„ ?ì’–ì˜‰)
  StudyTimer.start();

  // ?ëŒìŸ¾ ?ëª„ë€¡ è¹‚ë“­ì ?ì’•ë£„
  setTimeout(() => SessionSaver.restore(), 500);

  // ?ëš®â” æ²…ëš°ë¸³ ?ë¶¿ê»Œ (Pomodoro ?ëš®â”??
  if (Notification.permission === 'default') {
    Notification.requestPermission();
  }
}

// DOMContentLoaded ?ëŒ€ê¹½?ë©¸? ?ëŒ€? è«›ì’–ê¹®?ëˆë’—ï§Â€ ?ëº¤ì”¤ (?ìˆˆìŸ» ?ã…½ê²•ç”±ì€ë“ƒ æ¿¡ì’•ë±¶ ??
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeButtonHandlers);
} else {
  // ?ëŒ€? DOM??æ¿¡ì’•ë±¶???ê³¹ê¹­ï§?ï§ë±ë–† ?ã…½ë»¾
  initializeButtonHandlers();
}

// ========== DEFINITION QUIZ (Mode 5) ==========
let definitionStates = [];

function renderDefinitionQuiz(definitions, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  definitionStates = [];

  const frag = document.createDocumentFragment();

  definitions.forEach((def, idx) => {
    const defNum = idx + 1;
    const correctAnswer = def.definition;

    const cardDiv = document.createElement("div");
    cardDiv.className = "definition-card";
    cardDiv.id = `definition-${defNum}`;

    // ?â‘¹ë¼± (Front)
    const termDiv = document.createElement("div");
    termDiv.className = "definition-term";
    termDiv.innerHTML = `<span class="definition-num">#${defNum}</span> <strong>${escapeHtml(def.term)}</strong>?ëŒ€??`;
    cardDiv.appendChild(termDiv);

    // ?ë‚…ì ° ?ê³¸ë¿­ (Back - é®ë‰ë­)
    const inputDiv = document.createElement("div");
    inputDiv.className = "definition-input-area";

    const textarea = document.createElement("textarea");
    textarea.className = "definition-input";
    textarea.id = `def-input-${defNum}`;
    textarea.dataset.key = String(defNum);
    textarea.dataset.answer = correctAnswer;
    textarea.placeholder = "?ëº¤ì“½ç‘œ??ë‚…ì °?ì„ê½­??.. (Enteræ¿¡?AI ï§¢ê¾©ì )";
    textarea.rows = 2;

    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleDefinitionCheck(defNum);
      }
    });

    inputDiv.appendChild(textarea);
    cardDiv.appendChild(inputDiv);

    // å¯ƒê³Œë‚µ ?ì’–ë–†
    const resultDiv = document.createElement("div");
    resultDiv.className = "definition-result";
    resultDiv.id = `def-result-${defNum}`;
    cardDiv.appendChild(resultDiv);

    frag.appendChild(cardDiv);

    definitionStates.push({
      defNum,
      term: def.term,
      correctAnswer,
      answered: false,
      isCorrect: null,
      hasBeenWrong: false
    });
  });

  codeArea.appendChild(frag);
  renderDefinitionNav();
  sessionCount.textContent = definitions.length;
  hasAnswers = true;
  updateDefinitionScore();
}

async function handleDefinitionCheck(defNum) {
  const state = definitionStates.find(s => s.defNum === defNum);
  if (!state || state.answered) return;

  const textarea = document.getElementById(`def-input-${defNum}`);
  const userAnswer = textarea.value.trim();

  if (!userAnswer) {
    alert("?ëº¤ì“½ç‘œ??ë‚…ì °?ëŒï¼œ?ëª„ìŠ‚.");
    return;
  }

  const resultDiv = document.getElementById(`def-result-${defNum}`);
  resultDiv.innerHTML = `<span class="definition-loading">?ì¨º AIåª›Â€ ï§¢ê¾©ì  ä»¥?..</span>`;
  textarea.disabled = true;

  try {
    const isCorrect = await checkDefinitionWithAI(state.term, userAnswer, state.correctAnswer);

    state.answered = true;
    state.isCorrect = isCorrect;

    // ?ìˆˆë’¿ ?ë“¦í€ æ¹²ê³•ì¤‰
    LearningStats.recordAnswer(isCorrect);
    SoundEffects.play(isCorrect ? 'correct' : 'wrong');

    textarea.classList.remove("correct", "wrong", "revealed", "retried");
    resultDiv.innerHTML = "";

    if (isCorrect) {
      if (state.hasBeenWrong) {
        textarea.classList.add("retried");
        reviewQueue.add(String(defNum));
        resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ! (?Ñ‰ë£„???ê¹ƒë‚¬)</span>`;
      } else {
        textarea.classList.add("correct");
        reviewQueue.delete(String(defNum));
        resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ!</span>`;
      }
    } else {
      state.hasBeenWrong = true;
      textarea.classList.add("wrong");
      reviewQueue.add(String(defNum));
      resultDiv.innerHTML = `
        <span class="mc-wrong">???ê¾©ëº?ã…¼ìŠ‚. ?ë“­ë–– åª›ì’•ë€—??éºÂ€è­°ê¹Šë¹€?ëˆë–.</span>
        <div class="definition-correct-answer">
          <strong>ï§â‘¤ì¾¾ ?ë“­ë¸:</strong> ${escapeHtml(state.correctAnswer)}
        </div>`;
    }

    const nav = document.getElementById(`nav-def-${defNum}`);
    if (nav) {
      nav.classList.remove("pending", "correct", "wrong", "retried", "revealed");
      if (isCorrect) {
        nav.classList.add(state.hasBeenWrong ? "retried" : "correct");
      } else {
        nav.classList.add("wrong");
      }
    }

    updateDefinitionScore();

    // ?ã…¼ì“¬ è‡¾ëª„ì £æ¿¡??ÑŠë¹±??(?ëŒìŸ¾ ?ë“¬???è¹‚ëŒì” ?ê¾¨ì¤‰)
    const nextState = definitionStates.find(s => !s.answered);
    if (nextState) {
      const nextInput = document.getElementById(`def-input-${nextState.defNum}`);
      const nextCard = document.querySelector(`#def-input-${nextState.defNum}`)?.closest('.definition-card');
      if (nextCard) {
        setTimeout(() => {
          const cardRect = nextCard.getBoundingClientRect();
          const scrollTop = window.scrollY + cardRect.top - (window.innerHeight * 0.25);
          window.scrollTo({ top: scrollTop, behavior: 'smooth' });
        }, 100);
      }
      if (nextInput) {
        setTimeout(() => nextInput.focus(), 150);
      }
    }
  } catch (err) {
    textarea.disabled = false;
    resultDiv.innerHTML = `<span class="mc-wrong">???ã…»ìªŸ: ${err.message}</span>`;
  }
}

async function checkDefinitionWithAI(term, userAnswer, correctAnswer) {
  // ï§¤ì’–ëƒ¼ æ¹²ëª„ì”  å¯ƒÂ€??(?ëˆĞ¢ ï§ãƒ? ?ë“­? è‡¾ëŒâ€œå«„??ã…»ë–Ÿ)
  if (userAnswer.length < 10) {
    return false;
  }

  const prompt = `?ë±€ë–Š?Â€ ï§ã…¼ìŠ¦ ?ê¾§êº½??OOP æ¹²ê³•ì­š?ì’—ë¿• ï§¢ê¾©ì æ„¿Â€?ë‚…ë•²?? ?ìˆˆì  ?ëª…ëµ†?ëˆ? ?ë‰ìŠœ?ì„? ?ë”†ë’¿?ëˆë–.

**?â‘¹ë¼±**: "${term}"
**ï§â‘¤ì¾¾ ?ë“­ë¸**: "${correctAnswer}"
**?ìˆˆê¹®????*: "${userAnswer}"

## ï§¢ê¾©ì  æ¹²ê³—? (?ê¾§êº½?ì„ì¾¶ ?ê³¸ìŠœ)
1. **?ë“­ë–– ?ã…¼ì™???ê¾©ë‹”**: ï§â‘¤ì¾¾ ?ë“­ë¸???ë“­ë–– æ¹²ê³—ë‹  ?â‘¹ë¼±åª›Â€ ?Ñ‹ë¸¿?ì„ë¼±????2. **åª›ì’•ë€—???ê¾©ìŸ¾??*: ?ëº¤ì“½???ë“­ë–– ?ë¶¿ëƒ¼åª›Â€ ï§â‘¤ëª¢ ?ã…»ì±¸?ì„ë¼±????3. **æ¹²ê³—ë‹ ???ëº¥ì†—??*: CS ?ê¾§ë‚¬?ë¨­? è¹‚ë‹¿ë¦°???ëº¥ì†—???ã…»ì±¸?ëŒë¼±????
## è«›ì„ë±¶???ã…»ë–Ÿ ï§£ì„â”?ì„ë’— å¯ƒìŒìŠ¦
- "~ï§Â€ è¸?, "~?ëªƒë²", "~åª›ìˆˆì“¬" ???ì¢Šâ„“???ì’—ì½
- ?ë“­ë–– åª›ì’•ë€— ?ë†ì”  ?â‘¹ë¼±ï§?è«›ì„ë‚¬ (?? "?ê³•ì …?ì’•ë’— ?ê³•ì …?ì’•ë–")
- ï§Â€?ì„íŠ‚å¯ƒ?ï§ãêµ…??éºë‰ê½¦?ã…½ë¸³ ?ë“¬?
- ?ëº¤ì“½åª›Â€ ?ê¾¨ë•¶ ?ë‰ë–†ï§??ì„ë¿´
- æ¹²ê³—ë‹ ?ê³¸ì‘æ¿¡?éºÂ€?ëº¥ì†—???ã…»ì±¸

## ?ëº£ë–Ÿ?ì‡°ì¤ˆ ?ëª„ì ™?ì„ë’— å¯ƒìŒìŠ¦
- ï§â‘¤ì¾¾ ?ë“­ë¸æ€¨??ì’—ì½?Â€ ?ã…»â…¤ï§Â€ï§??ë“­ë–– åª›ì’•ë€—???ëº¥ì†—???ì‡±íŠ‚
- ç•°ë¶½? ?ã…»ì±¸???ë‰?ï§??ë“­ë––??ï§ìšì“¬

**?ë¨¯ì ™**: ??æ¹²ê³—????ê³•ì”ª ?ê¾§êº½?ì„ì¾¶ ?ë¨®ë–’?ì„ê½­??
JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ (?ã…»â…¨ ?ë¿ë’ª???ë†ì” ):
{"correct": true ?ë¨®ë’— false}`;

  try {
    const response = await callGeminiAPI(prompt, "JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ?ì„ê½­?? ï§¢ê¾©ì ?Â€ ?ê¾§êº½?ì„ì¾¶.");
    const jsonMatch = response.match(/\{[^}]+\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return result.correct === true;
    }
    // ?ëš¯ë–› ?ã…½ë™£ ???ê¾§êº½??é®ê¾§íƒ³
    return false;
  } catch (err) {
    console.error("AI grading error:", err);
    // AI ?ã…½ë™£ ?ì’–ë¿‰???ê¾§êº½?ì„ì¾¶ - ?ëº¥ì†—???ì‡±íŠ‚?ëŒë¹ ?ëº£ë–Ÿ
    const normalize = s => s.replace(/\s+/g, '').toLowerCase();
    return normalize(userAnswer) === normalize(correctAnswer);
  }
}

function renderDefinitionNav() {
  blankList.innerHTML = "";
  definitionStates.forEach((s) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-def-${s.defNum}`;
    btn.textContent = `#${s.defNum}`;
    btn.addEventListener("click", () => {
      const target = document.getElementById(`definition-${s.defNum}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
      const input = document.getElementById(`def-input-${s.defNum}`);
      if (input && !input.disabled) input.focus();
    });
    blankList.appendChild(btn);
  });
  applyNavFilter();
}

function updateDefinitionScore() {
  const total = definitionStates.length;
  const answered = definitionStates.filter(s => s.answered).length;
  const correct = definitionStates.filter(s => s.isCorrect).length;
  const retried = definitionStates.filter(s => s.isCorrect && s.hasBeenWrong).length;
  const wrong = definitionStates.filter(s => s.answered && !s.isCorrect).length;

  sessionScore.textContent = `${correct} / ${total}`;
  const ratio = total ? (correct / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    const reviewCount = wrong + retried + reviewQueue.size;
    if (reviewCount) {
      reviewBadge.textContent = `è¹‚ë“­ë’¿ ${reviewCount}åª›?;
    } else if (answered === total) {
      const percentage = Math.round(ratio);
      reviewBadge.textContent = `?ê¾¨ì¦º! ${correct}/${total} (${percentage}%)`;
      reviewBadge.style.color = percentage >= 60 ? "var(--green)" : "var(--red)";
    } else {
      reviewBadge.textContent = `?â‘¥? è‡¾ëª„ì £ ${total - answered}åª›?;
    }
  }
  applyNavFilter();
}

// ========== VOCABULARY CARDS (Mode 7) ==========
let vocabStates = [];

function renderVocabularyCards(words, answerKey, language) {
  codeArea.innerHTML = "";
  blankList.innerHTML = "";
  inputs = [];
  reviewQueue = new Set();
  vocabStates = [];

  const needsAI = answerKey._needs_ai_generation;

  const frag = document.createDocumentFragment();

  words.forEach((word, idx) => {
    const wordNum = idx + 1;
    const correctAnswer = word.korean || "[AI ?ì•¹ê½¦ ?ê¾©ìŠ‚]";

    const cardDiv = document.createElement("div");
    cardDiv.className = "vocab-card";
    cardDiv.id = `vocab-${wordNum}`;

    // ?ê³¸ë¼± ?â‘¥ë¼±
    const termDiv = document.createElement("div");
    termDiv.className = "vocab-term";
    termDiv.innerHTML = `<span class="vocab-num">#${wordNum}</span> <strong class="vocab-english">${escapeHtml(word.english)}</strong>`;
    cardDiv.appendChild(termDiv);

    // ?ì’“? ???ë‚…ì °/?ì’–ë–†
    const meaningDiv = document.createElement("div");
    meaningDiv.className = "vocab-meaning-area";

    if (word.needs_ai) {
      // AIåª›Â€ ?ì•¹ê½¦?ëŒë¹ ?ì„ë’— å¯ƒìŒìŠ¦
      const genBtn = document.createElement("button");
      genBtn.className = "vocab-gen-btn";
      genBtn.textContent = "?ì¨¼ AI ???ì•¹ê½¦";
      genBtn.addEventListener("click", () => generateVocabMeaning(wordNum, word.english));
      meaningDiv.appendChild(genBtn);

      const genResult = document.createElement("div");
      genResult.className = "vocab-gen-result";
      genResult.id = `vocab-gen-${wordNum}`;
      meaningDiv.appendChild(genResult);
    } else {
      // ?ëŒ€? ?ì‚´ì”  ?ëˆë’— å¯ƒìŒìŠ¦ - é®ë‰ë­ ?ëš¯ë’ª??      const textarea = document.createElement("textarea");
      textarea.className = "vocab-input";
      textarea.id = `vocab-input-${wordNum}`;
      textarea.dataset.key = String(wordNum);
      textarea.dataset.answer = correctAnswer;
      textarea.placeholder = "?ì‚´ì“£ ?ë‚…ì °?ì„ê½­??.. (Enteræ¿¡??ëº¤ì”¤)";
      textarea.rows = 1;

      textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleVocabCheck(wordNum);
        }
      });

      meaningDiv.appendChild(textarea);
    }

    cardDiv.appendChild(meaningDiv);

    // å¯ƒê³Œë‚µ ?ì’–ë–†
    const resultDiv = document.createElement("div");
    resultDiv.className = "vocab-result";
    resultDiv.id = `vocab-result-${wordNum}`;
    cardDiv.appendChild(resultDiv);

    frag.appendChild(cardDiv);

    vocabStates.push({
      wordNum,
      english: word.english,
      correctAnswer,
      needsAi: word.needs_ai,
      answered: false,
      isCorrect: null,
      hasBeenWrong: false
    });
  });

  codeArea.appendChild(frag);
  renderVocabNav();
  sessionCount.textContent = words.length;
  hasAnswers = !needsAI;
  updateVocabScore();
}

async function generateVocabMeaning(wordNum, english) {
  const resultDiv = document.getElementById(`vocab-gen-${wordNum}`);
  resultDiv.innerHTML = `<span class="definition-loading">?ì¨¼ AIåª›Â€ ?ì‚´ì“£ ?ì•¹ê½¦ ä»¥?..</span>`;

  const prompt = `?ê³¸ë¼± ?â‘¥ë¼± "${english}"???ì’“ë…???ì‚´ì“£ ?ëš®ì ®äºŒì‡±ê½­??

ä»¥ë¬’ìŠ‚ æ´¹ì’–íŠƒ:
1. ?â‘¥ë‹š ?ëš¯ë¿­(code?ë¯ªí«?? interface?ë¯ªì”¤?ê³ ëŸ¹?ëŒë’ª)?Â€ ?ëˆ? ???â‘¸ë•²??
2. ?ã…¼ì £ ?ì„?ç‘œ??ì’“ë…?ëŒ€ì¤ˆ ?ã…»ì±¸?ëŒï¼œ?ëª„ìŠ‚.
3. åª›ê¾§ê»?ì„ì¾¶ 1-2ä»¥ê¾¨ì¤ˆ ?ë¬’ê½¦?ì„ê½­??

JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ: {"meaning": "?ì’“ë…????}`;

  try {
    const response = await callGeminiAPI(prompt, "JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ?ì„ê½­??");
    const jsonMatch = response.match(/\{[^}]+\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      const meaning = result.meaning || "?ì•¹ê½¦ ?ã…½ë™£";

      resultDiv.innerHTML = `
        <div class="vocab-generated">
          <strong>??</strong> ${escapeHtml(meaning)}
        </div>`;

      // ?ê³¹ê¹­ ?ë‚…ëœ²?ëŒ„ë“ƒ
      const state = vocabStates.find(s => s.wordNum === wordNum);
      if (state) {
        state.correctAnswer = meaning;
        state.answered = true;
        state.isCorrect = true;
      }

      const nav = document.getElementById(`nav-vocab-${wordNum}`);
      if (nav) {
        nav.classList.remove("pending");
        nav.classList.add("correct");
      }

      updateVocabScore();
    }
  } catch (err) {
    resultDiv.innerHTML = `<span class="mc-wrong">???ã…»ìªŸ: ${err.message}</span>`;
  }
}

function handleVocabCheck(wordNum) {
  const state = vocabStates.find(s => s.wordNum === wordNum);
  if (!state || state.answered) return;

  const textarea = document.getElementById(`vocab-input-${wordNum}`);
  const userAnswer = textarea.value.trim();

  if (!userAnswer) return;

  const normalize = s => s.replace(/\s+/g, '').toLowerCase();
  const userNorm = normalize(userAnswer);

  const correctAnswers = state.correctAnswer.split(',').map(a => normalize(a.trim()));
  const isCorrect = correctAnswers.some(correct =>
    correct === userNorm ||
    correct.includes(userNorm) ||
    userNorm.includes(correct)
  );

  state.answered = true;
  state.isCorrect = isCorrect;
  textarea.disabled = true;
  textarea.classList.remove("correct", "wrong", "revealed", "retried");

  const resultDiv = document.getElementById(`vocab-result-${wordNum}`);

  if (isCorrect) {
    if (state.hasBeenWrong) {
      textarea.classList.add("retried");
      reviewQueue.add(String(wordNum));
      resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ! (?Ñ‰ë£„???ê¹ƒë‚¬)</span> <span style="color: var(--muted); margin-left: 8px;">(${escapeHtml(state.correctAnswer)})</span>`;
    } else {
      textarea.classList.add("correct");
      reviewQueue.delete(String(wordNum));
      resultDiv.innerHTML = `<span class="mc-correct">???ëº£ë–Ÿ!</span> <span style="color: var(--muted); margin-left: 8px;">(${escapeHtml(state.correctAnswer)})</span>`;
    }
  } else {
    state.hasBeenWrong = true;
    textarea.classList.add("wrong");
    reviewQueue.add(String(wordNum));
    textarea.value = state.correctAnswer;
    textarea.classList.remove("wrong");
    textarea.classList.add("revealed");
    resultDiv.innerHTML = `<span class="mc-wrong">???ã…»ë–Ÿ. ?ëº£ë–Ÿ: ${escapeHtml(state.correctAnswer)}</span> <button onclick="explainWhyWrong(${wordNum}, 'vocab')" style="margin-left: 8px; background: linear-gradient(135deg, #ff6b6b, #ee5a5a); color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">???Â€?ëªƒêµ¹??</button>`;
  }

  const nav = document.getElementById(`nav-vocab-${wordNum}`);
  if (nav) {
    nav.classList.remove("pending", "correct", "wrong", "revealed", "retried");
    if (isCorrect) {
      nav.classList.add(state.hasBeenWrong ? "retried" : "correct");
    } else {
      nav.classList.add("wrong");
    }
  }

  updateVocabScore();

  const nextState = vocabStates.find(s => !s.answered && !s.needsAi);
  if (nextState) {
    const nextCard = document.getElementById(`vocab-${nextState.wordNum}`);
    const nextInput = document.getElementById(`vocab-input-${nextState.wordNum}`);

    if (nextCard) {
      setTimeout(() => {
        nextCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => {
          if (nextInput && !nextInput.disabled) {
            nextInput.focus({ preventScroll: true });
          }
        }, 120);
      }, 80);
    }
  }
}

function updateVocabScore() {
  const total = vocabStates.length;
  const answered = vocabStates.filter(s => s.answered).length;
  const correct = vocabStates.filter(s => s.isCorrect).length;
  const retried = vocabStates.filter(s => s.isCorrect && s.hasBeenWrong).length;
  const wrong = vocabStates.filter(s => s.answered && !s.isCorrect).length;

  sessionScore.textContent = `${correct} / ${total}`;
  const ratio = total ? (correct / total) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;

  if (reviewBadge) {
    const reviewCount = wrong + retried + reviewQueue.size;
    if (reviewCount) {
      reviewBadge.textContent = `è¹‚ë“­ë’¿ ${reviewCount}åª›?;
    } else if (answered === total) {
      reviewBadge.textContent = `?ê¾¨ì¦º! ${correct}/${total}`;
    } else {
      reviewBadge.textContent = `?â‘¥? ?â‘¥ë¼± ${total - answered}åª›?;
    }
  }
  applyNavFilter();
}

function renderVocabNav() {
  if (!blankList || !vocabStates || vocabStates.length === 0) return;

  blankList.innerHTML = "";
  vocabStates.forEach((s) => {
    const btn = document.createElement("div");
    btn.className = "blank-pill pending";
    btn.id = `nav-vocab-${s.wordNum}`;
    btn.textContent = `V${s.wordNum}`;

    if (s.answered) {
      btn.classList.remove("pending");
      btn.classList.add(s.isCorrect ? "correct" : "wrong");
      if (s.hasBeenWrong && s.isCorrect) {
        btn.classList.add("retried");
      }
    }

    btn.addEventListener("click", () => {
      const target = document.getElementById(`vocab-${s.wordNum}`);
      if (target) target.scrollIntoView({ behavior: "smooth", block: "center" });
    });
    blankList.appendChild(btn);
  });
  applyNavFilter();
}

// ========== FILE/MODE SELECTION MODAL ==========
function initializeFileModeModal() {
  const modal = document.getElementById("file-mode-modal");
  const btnOpen = document.getElementById("btn-file-mode");
  const btnCancel = document.getElementById("btn-cancel-fm");
  const btnGenerate = document.getElementById("btn-generate-session");
  const statusEl = document.getElementById("fm-status");
  const selectedFileEl = document.getElementById("selected-file-name");

  // ?ê¾©ì˜± ?ì¢ê¹® ?ê³¹ê¹­
  let selectedPreset = "oop_vocab";
  let selectedMode = 7;

  const fileNames = {
    "oop_vocab": "1_OOP_?ê³·ë–’??txt",
    "oop_concept": "2_OOP_åª›ì’•ë€—??txt",
    "oop_code": "3_OOP_è‚„ë¶¾ë±¶é®ë‰ë­.txt",
    "data_structure": "4_?ë¨®ì¦ºæ´ÑŠâ€œ_è‚„ë¶¾ë±¶.txt",
    "math_theory": "5_?ê¾©ê¶›?ì„‘ë¸°_?ê¾§ë¦°.txt",
    "math_practice": "6_?ê¾©ê¶›?ì„‘ë¸°_?ã…ºë¦°.txt"
  };

  // ï§â‘¤ë–– ?ë¨®ë£ ?ì’–ë–† ?â‘¥ë‹”
  function showFileModeModal() {
    if (modal) {
      modal.style.display = "flex";
      if (statusEl) {
        statusEl.textContent = "";
        statusEl.className = "fm-status";
      }
    }
  }

  // ?ëª„ë€¡ ?ê³¹ê¹­ ?ëº¤ì”¤ - é®ê¾©ë¼±?ë‡êµ…???ëŒ€ê°š ?ëª„ë€¡?ëŒ€ãˆƒ ï§â‘¤ë–– ?ë¨®ë£ ?ì’–ë–†
  function checkSessionAndShowModal() {
    // currentSession???ë…¾êµ…???ëŒ€ê°š ?ëª„ë€¡?ëª„? ?ëº¤ì”¤
    if (!currentSession) {
      console.log("?ëª„ë€¡ ?ë†ì“¬ - ï§â‘¤ë–– ?ì’–ë–†");
      showFileModeModal();
      return;
    }

    // ?ëŒ€ê°š ?ëª„ë€¡ åª›ë¨¯?: title??"æ¹²ê³•ë‚¯ ?ëª„ë€¡"?ë‹¿êµ…??answer_keyåª›Â€ é®ê¾©ë¼±?ëˆë’— å¯ƒìŒìŠ¦
    const isFallbackSession =
      currentSession.title === "æ¹²ê³•ë‚¯ ?ëª„ë€¡" ||
      (!currentSession.answer_key) ||
      (currentSession.answer_key._type === "whiteboard" &&
        (!currentSession.answer_key._challenges || currentSession.answer_key._challenges.length === 0));

    if (isFallbackSession) {
      console.log("?ëŒ€ê°š ?ëª„ë€¡ åª›ë¨¯? - ï§â‘¤ë–– ?ì’–ë–†");
      showFileModeModal();
    }
  }

  // ?ëª„ë€¡ ?ê³¹ê¹­ ?ëº¤ì”¤ - initializeApp?ë¨¯ê½Œ ?ëŒ€? ?ëª„ë€¡??æ¿¡ì’•ë±¶?ë‰ì‘èª˜Â€æ¿¡?ï§ë±ë–† ï§£ëŒ„ê²•
  checkSessionAndShowModal();

  // ï§â‘¤ë–– ?ë‹¿ë¦°
  if (btnOpen) {
    btnOpen.addEventListener("click", () => {
      modal.style.display = "flex";
      statusEl.textContent = "";
      statusEl.className = "fm-status";
    });
  }

  // ï§â‘¤ë–– ?ãƒªë¦°
  if (btnCancel) {
    btnCancel.addEventListener("click", () => {
      modal.style.display = "none";
    });
  }

  // ?ê¾¨â”???ëš¯ì”ª ?ì¢ê¹®
  document.querySelectorAll(".fm-preset:not(.fm-upload)").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".fm-preset").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      selectedPreset = btn.dataset.preset;
      customFileContent = null; // ?ê¾¨â”???ì¢ê¹® ??è€Œã…¼ë’ª?Â€ ?ëš¯ì”ª ç¥ë‡ë¦°??      selectedFileEl.textContent = fileNames[selectedPreset] || selectedPreset;

      // æ¹²ê³•ë‚¯ ï§â‘¤ë±¶ ?ë¨®ë£ ?ì¢ê¹® (data-default-mode ?ë¿ê½¦)
      const defaultMode = btn.dataset.defaultMode;
      if (defaultMode) {
        selectedMode = parseInt(defaultMode, 10);
        // ï§â‘¤ë±¶ è¸°ê¾ªë“‰ UI ?ë‚…ëœ²?ëŒ„ë“ƒ
        document.querySelectorAll(".fm-mode").forEach(m => m.classList.remove("active"));
        const modeBtn = document.querySelector(`.fm-mode[data-mode="${defaultMode}"]`);
        if (modeBtn) modeBtn.classList.add("active");
      }

      // C# OOP è‚„ë¶¾ë±¶ ?ì¢ê¹® ??AI è«›â‘¹ë–‡ ?ë¨®ë£ ?ì¢ê¹®
      if (selectedPreset === "oop_code") {
        selectedMethod = "ai";
        document.querySelectorAll(".fm-method").forEach(m => m.classList.remove("active"));
        const aiMethodBtn = document.querySelector('.fm-method[data-method="ai"]');
        if (aiMethodBtn) aiMethodBtn.classList.add("active");
      }
    });
  });

  // ï§£?è¸°ë‰ã ?ê¾¨â”???ì’–ê½¦??+ æ¹²ê³•ë‚¯ ï§â‘¤ë±¶ ?ã…¼ì ™
  const firstPreset = document.querySelector('.fm-preset:not(.fm-upload)');
  if (firstPreset) {
    firstPreset.classList.add('active');
    // ï§£??ê¾¨â”?ë—­ì“½ æ¹²ê³•ë‚¯ ï§â‘¤ë±¶???ê³¸ìŠœ
    const defaultMode = firstPreset.dataset.defaultMode;
    if (defaultMode) {
      selectedMode = parseInt(defaultMode, 10);
      document.querySelectorAll(".fm-mode").forEach(m => m.classList.remove("active"));
      const modeBtn = document.querySelector(`.fm-mode[data-mode="${defaultMode}"]`);
      if (modeBtn) modeBtn.classList.add("active");
    }
  }

  // ?ëš¯ì”ª ?ë‚…ì¤ˆ???ëªƒë±¾??  let customFileContent = null;
  let customFileName = null;
  const customFileInput = document.getElementById("custom-file-input");
  const uploadLabel = document.querySelector(".fm-upload");

  if (customFileInput) {
    customFileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        customFileContent = await file.text();
        customFileName = file.name;
        selectedPreset = "custom"; // è€Œã…¼ë’ª?Â€ ?ëš¯ì”ª ?ì’–ë–†

        // UI ?ë‚…ëœ²?ëŒ„ë“ƒ
        document.querySelectorAll(".fm-preset").forEach(b => b.classList.remove("active"));
        if (uploadLabel) uploadLabel.classList.add("active");
        selectedFileEl.textContent = `?ë±š ${file.name}`;

        statusEl.textContent = `???ëš¯ì”ª æ¿¡ì’•ë±¶ ?ê¾¨ì¦º: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`;
        statusEl.className = "fm-status";
      } catch (err) {
        statusEl.textContent = `???ëš¯ì”ª ?ì„ë¦° ?ã…»ìªŸ: ${err.message}`;
        statusEl.className = "fm-status error";
      }
    });
  }

  // ï§â‘¤ë±¶ ?ì¢ê¹®
  document.querySelectorAll(".fm-mode").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".fm-mode").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      selectedMode = parseInt(btn.dataset.mode, 10);
    });
  });

  // ?ì•¹ê½¦ è«›â‘¹ë–‡ ?ì¢ê¹®
  let selectedMethod = "local";
  document.querySelectorAll(".fm-method").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".fm-method").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      selectedMethod = btn.dataset.method;
    });
  });

  // ?ëª„ë€¡ ?ì•¹ê½¦
  if (btnGenerate) {
    btnGenerate.addEventListener("click", async () => {
      // ===== ï§â‘¤ë±¶ 6: ?ê¾©ê¶›?ì„‘ë¸° è‚„ë¶¾ë±¶ ?ë¬’ê½¦ (?ê¾¨ì¤?ëª„ë¿?ì’–ë¿‰??ï§ê³¸ì ’ ï§£ì„â”) =====
      if (selectedMode === 6) {
        statusEl.textContent = "?ì¨¼ AIåª›Â€ è‚„ë¶¾ë±¶ ?ë¬’ê½¦ è‡¾ëª„ì £ç‘œ??ì•¹ê½¦ ä»¥?..";
        modal.style.display = "none";
        await renderMode6CodeWriting();
        return;
      }

      // ===== ï§â‘¤ë±¶ 1: C# OOP è¹‚Â€??é®ë‰ë­ (?ê¾¨ì¤?ëª„ë¿?ì’–ë¿‰??ï§ê³¸ì ’ ï§£ì„â”) =====
      if (selectedMode === 1) {
        statusEl.textContent = "?ì¨¼ AIåª›Â€ C# OOP è¹‚Â€??è‡¾ëª„ì £ç‘œ??ì•¹ê½¦ ä»¥?..";
        modal.style.display = "none";
        await renderMode1OOPBlanks();
        return;
      }

      const methodLabel = selectedMethod === "ai" ? "?ì¨¼ AIæ¿¡? : "??æ¿¡ì’–ëº„?ë¨¯ê½Œ";
      statusEl.textContent = `${methodLabel} ?ëª„ë€¡ ?ì•¹ê½¦ ä»¥?..`;
      statusEl.className = "fm-status";
      btnGenerate.disabled = true;

      try {
        // ?ë¶¿ê»Œ ?ê³—ì” ??æ´ÑŠê½¦
        const requestData = {
          preset: selectedPreset,
          mode: selectedMode,
          method: selectedMethod
        };

        // è€Œã…¼ë’ª?Â€ ?ëš¯ì”ª???ì¢ê¹®??å¯ƒìŒìŠ¦ ?ëš¯ì”ª ?ëŒìŠœ ?Ñ‹ë¸¿
        if (selectedPreset === "custom" && customFileContent) {
          requestData.content = customFileContent;
          requestData.fileName = customFileName;
        }

        const response = await fetch("/api/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestData)
        });

        const result = await response.json();

        if (result.success) {
          const countInfo = result.questions
            ? `${result.questions}åª›?è‡¾ëª„ì £`
            : result.challenges
              ? `${result.challenges}åª›?ï§¢ëš®â”›ï§Â€`
              : `${result.blanks || 0}åª›?é®ë‰ë­`;
          statusEl.textContent = `???ëª„ë€¡ ?ì•¹ê½¦ ?ê¾¨ì¦º! (${countInfo})`;
          statusEl.className = "fm-status";

          // ?ëª„ë€¡ ?ã…¼ë–† æ¿¡ì’•ë±¶ (ç”±Ñ‰ì¤ˆ???ë†ì” )
          setTimeout(async () => {
            try {
              const sessionResponse = await fetch('session.json?t=' + Date.now());
              if (sessionResponse.ok) {
                const sessionData = await sessionResponse.json();
                setSession(sessionData);
                modal.style.display = 'none';
              }
            } catch (e) {
              console.error('?ëª„ë€¡ ?ëˆì¤ˆæ€¨ì¢ë¬  ?ã…½ë™£:', e);
            }
          }, 300);
        } else {
          statusEl.textContent = `???ã…»ìªŸ: ${result.error}`;
          statusEl.className = "fm-status error";
        }
      } catch (err) {
        statusEl.textContent = `???ã…½ë“ƒ?ëš°ê²• ?ã…»ìªŸ: ${err.message}`;
        statusEl.className = "fm-status error";
      } finally {
        btnGenerate.disabled = false;
      }
    });
  }

  // ï§â‘¤ë–– è«›ë¶½ë¬‘ ?ëŒ€â”ƒ ???ãƒªë¦°
  if (modal) {
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.style.display = "none";
      }
    });
  }
}

// ?ìˆˆìŸ» ?ã…½ê²•ç”±ì€ë“ƒ æ¿¡ì’•ë±¶ ?Â€??+ ?ëª„ë€¡ ?ë¨®ë£ æ¿¡ì’•ë±¶
async function initializeApp() {
  // ?ëª„ë€¡ ç™’ì‡±? æ¿¡ì’•ë±¶ (?ì’•ì¾­åª›Â€ ?ëŒ€? ?ì•¹ê½¦??session.json)
  try {
    const response = await fetch('session.json?t=' + Date.now());
    if (response.ok) {
      const data = await response.json();
      setSession(data);
      console.log('?ëª„ë€¡ æ¿¡ì’•ë±¶ ?ê¹ƒë‚¬:', data.title || 'untitled');
    } else {
      console.log('session.json ?ë†ì“¬, ï§â‘¤ë––?ë¨¯ê½Œ ?ì•¹ê½¦ ?Â€æ¹²?);
    }
  } catch (e) {
    console.log('?ëª„ë€¡ æ¿¡ì’•ë±¶ ?ã…½ë™£:', e.message);
  }

  // ï§â‘¤ë–– ç¥ë‡ë¦°??(?ëª„ë€¡ æ¿¡ì’•ë±¶ ??
  initializeFileModeModal();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  initializeApp();
}

// ========== MOBILE NAV TOGGLE ==========
(function () {
  const blankNav = document.getElementById('blank-nav');
  const btnToggleNav = document.getElementById('btn-toggle-nav');
  const btnShowNav = document.getElementById('btn-show-nav');

  if (btnShowNav) {
    btnShowNav.addEventListener('click', () => {
      blankNav?.classList.add('show');
    });
  }

  if (btnToggleNav) {
    btnToggleNav.addEventListener('click', () => {
      blankNav?.classList.remove('show');
    });
  }

  // é®ë‰ë­ ï§â‘¸ì¤‰?ë¨¯ê½Œ ??ã‰ ?ëŒ€â”ƒ ???ë¨®ë£?ì‡°ì¤ˆ ?ãƒªë¦° (ï§â‘¤ì»®??
  document.getElementById('blank-list')?.addEventListener('click', (e) => {
    if (e.target.classList.contains('blank-pill')) {
      if (window.innerWidth <= 768) {
        blankNav?.classList.remove('show');
      }
    }
  });
})();

// ========== CACHE CLEAR ON UNLOAD ==========
window.addEventListener("unload", () => {
  // é‡‰ëš®ì”ª?ê³—? ï§¦ë¨¯ë–† ç¥ë‡ë¦°???ì’•ë£„
  if ('caches' in window) {
    caches.keys().then(names => {
      names.forEach(name => caches.delete(name));
    });
  }
});

// ============================================================================
// ï§â‘¤ë±¶ 6: ?ê¾©ê¶›?ì„‘ë¸° è‚„ë¶¾ë±¶ ?ë¬’ê½¦ ï§â‘¤ë±¶
// ----------------------------------------------------------------------------
// ï§â‘¹ìŸ»: æ´ë¨¯ë‹”?ì„ì“½ ?ê¾©ê¶›?ì„‘ë¸° ?ì’—ë¿• ?Â€é®?// - AIåª›Â€ "ï§ë¶¾ë± ??æ€¨ê¾©ê¶›æ¹²???CSV ?Â€?????ë¨®ë–????æ´¹ëªƒì˜’?? ?ë¨®ì««??æ¹²ê³•ì»²??è‡¾ëª„ì £ ?ì•¹ê½¦
// - ?ìˆˆê¹®???ê¾©ê»œ è‚„ë¶¾ë±¶ç‘œ?ï§ê³¸ì ’ ?ë¬’ê½¦
// - AIåª›Â€ æ¿¡ì’–ì­…/?ë¨®ì««??ï§ìšì‘ï§??ëº£ë–Ÿ?ì‡°ì¤ˆ ï§¢ê¾©ì  (?ë“¯ë„»???ë‡ì¾¶)
// ============================================================================

// ï§â‘¤ë±¶ 6 ?ê³¹ê¹­ æ„¿Â€ç”±?let mode6State = {
  problem: '',       // è‡¾ëª„ì £ ?ã…»ì±¸
  sampleCode: '',    // ï§¡ë©¸í€¬???ì„‘ëµ† è‚„ë¶¾ë±¶ (ï§¢ê¾©ì  ??é®ê¾§íƒ³??
  userCode: '',      // ?ÑŠìŠœ?ë¨­? ?ë¬’ê½¦??è‚„ë¶¾ë±¶
  submitted: false,  // ?ì’–í…§ ?Ñ‰?
  isCorrect: null    // ï§¢ê¾©ì  å¯ƒê³Œë‚µ
};

/**
 * ï§â‘¤ë±¶ 6 ?ëš®ëœ‘ï§??â‘¥ë‹”
 * - AIåª›Â€ ?ê¾©ê¶›?ì„‘ë¸° ?ã…½??ì‡±ì“½ è‚„ë¶¾ë±¶ ?ë¬’ê½¦ è‡¾ëª„ì £ç‘œ??ì•¹ê½¦?ì„í€¬ ?ë¶¾ãˆƒ???ì’–ë–†
 * - ï§ë¶¾ë±/æ€¨ê¾©ê¶›æ¹²?CSV/?ë¨®ë–??æ´¹ëªƒì˜’???ë¨®ì««??è¹‚Â€?ëº¥ë¸³ è‡¾ëª„ì £
 */
async function renderMode6CodeWriting() {
  const codeArea = document.getElementById('code-area');
  codeArea.innerHTML = `<div class="definition-loading">?ì¨¼ AIåª›Â€ ?ê¾©ê¶›?ì„‘ë¸° è‚„ë¶¾ë±¶ ?ë¬’ê½¦ è‡¾ëª„ì £ç‘œ??ì•¹ê½¦ ä»¥?..</div>`;

  // ?ì’•ã‰ ?ë‚…ëœ²?ëŒ„ë“ƒ
  sessionTitle.textContent = "?ê¾©ê¶›?ì„‘ë¸° è‚„ë¶¾ë±¶ ?ë¬’ê½¦";
  sessionMode.textContent = "è‚„ë¶¾ë±¶ ?ë¬’ê½¦ (AI ï§¢ê¾©ì )";

  // AI?ë¨­ì¾¶ è‡¾ëª„ì £ ?ì•¹ê½¦ ?ë¶¿ê»Œ
    // AI?? ?? ??? ??
    // AIì—ê²Œ ë¬¸ì œ ìƒì„±ì„ ìš”ì²­
  const prompt = `ë‹¹ì‹ ì€ ì „ì‚°ìˆ˜í•™ êµìˆ˜ì´ì ì‹¤ìŠµ ì¶œì œìì…ë‹ˆë‹¤.
ë‹¤ìŒ 'ì „ì‚°ìˆ˜í•™ ì‹¤ê¸° ë©”ë‰´ë„ìš°ë¯¸' ê¸°ë³¸ ìš”êµ¬ì‚¬í•­ì„ ë°˜ë“œì‹œ í¬í•¨í•œ ì‹¤ìŠµ ê³¼ì œë¥¼ í•˜ë‚˜ ë§Œë“¤ì–´ ì£¼ì„¸ìš”.
- íŒŒì´ì¬ ì»¨ì†” ë©”ë‰´ ë£¨í”„ë¡œ ì‚¬ì¹™ì—°ì‚°(+,-,*,/) ìˆ˜í–‰ ë° ê¸°ë¡
- ì¢…ë£Œ ì‹œ ê¸°ë¡ì„ utf-8-sig CSVë¡œ ì €ì¥Â·ë¶ˆëŸ¬ì˜¤ê¸° ì§€ì›
- pandas + matplotlibë¡œ ê¸°ë¡ ê·¸ë˜í”„ ì¶œë ¥
- ë³€í˜•ì€ "ì•„ì£¼ ì‘ì€ ì¶”ê°€ ì¡°ê±´ 1~2ê°œ" ìˆ˜ì¤€ë§Œ í—ˆìš©(ì˜ˆ: ë©”ë‰´ ì…ë ¥ ê²€ì¦ ì¶”ê°€, ì •ë ¬/í•„í„° ì˜µì…˜ 1ê°œ, ëˆ„ì  í†µê³„ 1ê°œ). ê³¼ë„í•œ ì œì•½ì´ë‚˜ ë³´í¸ íŒ¨í„´ ê¸ˆì§€.
- í•™ìƒì´ ë°”ë¡œ ë”°ë¼ì¹¨ ìˆ˜ ìˆëŠ” ë‹¨ì¼ íŒŒì¼ êµ¬ì¡°, ê³¼í•œ HTML/Canvas ì¶œë ¥ ì—†ìŒ.

JSONìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”:
{
  "problem_title": "ì‹¤ìŠµ ë¬¸ì œ ì œëª©",
  "problem_description": "ê¸°ë³¸ ìš”êµ¬ì‚¬í•­ì„ í¬í•¨í•˜ê³ , ê°€ë³ê²Œ ë³€í˜•ëœ ìƒì„¸ ì„¤ëª…",
  "requirements": ["í•„ìˆ˜ ìš”êµ¬ì‚¬í•­1", "í•„ìˆ˜ ìš”êµ¬ì‚¬í•­2", "í•„ìˆ˜ ìš”êµ¬ì‚¬í•­3"],
  "sample_code": "ì •ë‹µ ì˜ˆì‹œ ì½”ë“œë¥¼ ì§§ê²Œ. ì±„ì ìš© ê¸°ì¤€ì´ì§€ë§Œ í•™ìƒì—ê²ŒëŠ” ìˆ¨ê¹€"
}`;
`;

try {
    const response = await callGeminiAPI(prompt, "JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ?ì„ê½­?? è‚„ë¶¾ë±¶ é‡‰ë¶¾ì¤‰ ?ë†ì”  ?ì’–ë‹” JSONï§?");

    // JSON ?ëš¯ë–›
    let problemData;
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        problemData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("JSON ?ëš¯ë–› ?ã…½ë™£");
      }
    } catch (e) {
      throw new Error("è‡¾ëª„ì £ ?ì•¹ê½¦ ?ã…½ë™£: " + e.message);
    }

    // ?ê³¹ê¹­ ?Â€??    mode6State = {
      problem: problemData.problem_description,
      sampleCode: problemData.sample_code || '',
      userCode: '',
      submitted: false,
      isCorrect: null
    };

    // UI ?ëš®ëœ‘ï§?    codeArea.innerHTML = `
      <div class="mode6-container" style="max-width: 900px; margin: 0 auto;">
        <!-- è‡¾ëª„ì £ ?ã…»ì±¸ ç§»ëŒ€ë±¶ -->
        <div class="mode6-problem-card" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
          <h2 style="color: #667eea; margin: 0 0 12px 0;">?ë±· ${escapeHtml(problemData.problem_title)}</h2>
          <p style="color: var(--text); line-height: 1.7; white-space: pre-line;">${escapeHtml(problemData.problem_description)}</p>
          
          <div style="margin-top: 16px;">
            <h4 style="color: var(--accent-2); margin: 0 0 8px 0;">???ë¶½ë„?Ñ‹ë¹†</h4>
            <ul style="color: var(--text); margin: 0; padding-left: 20px;">
              ${problemData.requirements.map(r => `<li>${escapeHtml(r)}</li>`).join('')}
            </ul>
          </div>
        </div>
        
        <!-- è‚„ë¶¾ë±¶ ?ë‚…ì ° ?ê³¸ë¿­ -->
        <div class="mode6-input-area" style="margin-bottom: 20px;">
          <h3 style="color: var(--accent); margin: 0 0 12px 0;">?ë®² è‚„ë¶¾ë±¶ ?ë¬’ê½¦</h3>
          <textarea id="mode6-code-input" 
            class="challenge-textarea" 
            placeholder="# ?Ñˆë¦°???ê¾©ê»œ è‚„ë¶¾ë±¶ç‘œ??ë¬’ê½¦?ì„ê½­??..
import pandas as pd
import matplotlib.pyplot as plt

def main():
    # ï§ë¶¾ë± æ¹²ê³•ì»² ?ê¾¨ì¤ˆæ´¹ëªƒì˜© ?ì’–ì˜‰
    ...

if __name__ == '__main__':
    main()"
            style="width: 100%; min-height: 400px; font-family: var(--font-code); font-size: 14px; padding: 16px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text); resize: vertical;"
            spellcheck="false"></textarea>
        </div>
        
        <!-- è¸°ê¾ªë“‰ ?ê³¸ë¿­ -->
        <div class="mode6-buttons" style="display: flex; gap: 12px; flex-wrap: wrap;">
          <button id="mode6-submit-btn" onclick="submitMode6Code()" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 600;">?? ?ì’–í…§ è«›?AI ï§¢ê¾©ì </button>
          <button onclick="resetMode6()" style="padding: 12px 24px; background: var(--muted); color: var(--text); border: none; border-radius: 8px; cursor: pointer;">?ë´½ ç¥ë‡ë¦°??/button>
          <button onclick="showMode6Hint()" style="padding: 12px 24px; background: rgba(255, 107, 107, 0.2); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 8px; cursor: pointer;">?ë®• ?ëš°ë“ƒ è¹‚ë‹¿ë¦°</button>
        </div>
        
        <!-- å¯ƒê³Œë‚µ ?ê³¸ë¿­ -->
        <div id="mode6-result" class="mode6-result" style="margin-top: 20px;"></div>
      </div>
    `;

    // è‚„ë¶¾ë±¶ ?ë‚…ì ° ??Tab ï§£ì„â”
    const codeInput = document.getElementById('mode6-code-input');
    codeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = codeInput.selectionStart;
        const end = codeInput.selectionEnd;
        codeInput.value = codeInput.value.substring(0, start) + '    ' + codeInput.value.substring(end);
        codeInput.selectionStart = codeInput.selectionEnd = start + 4;
      }
    });

    // ?ëª„ë€¡ ç§»ëŒìŠ«???ë‚…ëœ²?ëŒ„ë“ƒ
    sessionCount.textContent = "1";

  } catch (err) {
    codeArea.innerHTML = `<div class="mc-wrong" style="padding: 20px;">??è‡¾ëª„ì £ ?ì•¹ê½¦ ?ã…»ìªŸ: ${err.message}<br><br><button onclick="renderMode6CodeWriting()" style="padding: 10px 20px; background: var(--accent-2); border: none; border-radius: 6px; cursor: pointer;">?ë´½ ?ã…¼ë–† ?ì’•ë£„</button></div>`;
  }
}

/**
 * ï§â‘¤ë±¶ 6 è‚„ë¶¾ë±¶ ?ì’–í…§ è«›?AI ï§¢ê¾©ì 
 * - ?ìˆˆê¹®???ë¬’ê½¦??è‚„ë¶¾ë±¶ç‘œ?AIåª›Â€ ï§¢ê¾©ì 
 * - æ¿¡ì’–ì­…/?ë¨®ì««??ï§ìšì‘ï§??ëº£ë–Ÿ?ì‡°ì¤ˆ ?ë“¯ë„»???ë‡ì¾¶ ï§¢ê¾©ì 
 */
async function submitMode6Code() {
  const codeInput = document.getElementById('mode6-code-input');
  const resultDiv = document.getElementById('mode6-result');
  const userCode = codeInput.value.trim();

  if (!userCode) {
    alert('è‚„ë¶¾ë±¶ç‘œ??ë‚…ì °?ëŒï¼œ?ëª„ìŠ‚!');
    return;
  }

  mode6State.userCode = userCode;
  resultDiv.innerHTML = `<div class="definition-loading">?ì¨¼ AIåª›Â€ è‚„ë¶¾ë±¶ç‘œ?éºê¾©ê½?ì„í€¬ ï§¢ê¾©ì  ä»¥?..</div>`;

  const prompt = `?ë±€ë–Š?Â€ ?ê¾©ê¶›?ì„‘ë¸° ?ì’—ë¿• ï§¢ê¾©ì æ„¿Â€?ë‚…ë•²?? ?ë“¯ë„»???ë‡ì¾¶ ï§¢ê¾©ì ?ì„ë¦º, ?ë“­ë–– æ¿¡ì’–ì­…??ï§ìšë¸˜???â‘¸ë•²??

## è‡¾ëª„ì £ ?ã…»ì±¸
${mode6State.problem}

## ?ìˆˆê¹®???ë¬’ê½¦??è‚„ë¶¾ë±¶
\`\`\`python
${userCode}
\`\`\`

## ï§¢ê¾©ì  æ¹²ê³—? (?ë“¯ë„»???ë‡ì¾¶)
1. ?ë“­ë–– æ¹²ê³•ë’« æ´Ñ‹ì½ ?Ñ‰? (70% é®ê¾©ì¨·):
   - ï§ë¶¾ë± æ¹²ê³•ì»² while çŒ·â‘¦ë´½åª›Â€ ?ëˆë’—åª›Â€?
   - ?ÑŠíŠƒ?ê³—ê¶› ?ë¨®ë’— ?ë“­ë–– æ€¨ê¾©ê¶› æ¿¡ì’–ì­…???ëˆë’—åª›Â€?
   - ?ê³—ì” ???Â€??æ´ÑŠâ€œ(ç”±ÑŠë’ª???ëº¤ë€›?ëˆâ”)åª›Â€ ?ëˆë’—åª›Â€?
   
2. ?ëš¯ì”ª/?ì’“ì»–??(30% é®ê¾©ì¨·):
   - CSV ?Â€???ë¨®ë’— pandas ?ÑŠìŠœ ?ì’•ë£„åª›Â€ ?ëˆë’—åª›Â€?
   - matplotlib æ´¹ëªƒì˜’???ì’•ë£„åª›Â€ ?ëˆë’—åª›Â€?
   
3. ?ëº£ë–Ÿ æ¹²ê³—?:
   - 70% ?ëŒê¸½ æ´Ñ‹ì½?ì„ãˆƒ ?ëº£ë–Ÿ
   - ?ë“­ë–– æ¿¡ì’–ì­… æ´ÑŠâ€œï§?ï§ìšë¸˜??OK (è¹‚Â€?ì„ì±¸, ç•°ì’•ì ° ï§ë¶¿ë–†ï§Â€ ?Ñ‰ì”ª????
   - è‡¾ëªƒì¾¿ ?ã…»ìªŸåª›Â€ é†«Â€ ?ë‰ë¼±??æ¿¡ì’–ì­…??ï§ìšì‘ï§??ëº£ë–Ÿ

## ?ë¬ë–Ÿ ?ëº¤ë–‡ (JSON)
{
  "score": 0~100 ?ë¨¯ë‹”,
  "passed": true ?ë¨®ë’— false (70???ëŒê¸½?ëŒ€ãˆƒ true),
  "feedback": "?ê³¸ê½­???ì‡°ë±¶è«›?(?ì„‘ë¸³ ?? éºÂ€è­°ê¹Šë¸³ ??",
  "missing": ["?ê¾¨ì”«??æ¹²ê³•ë’«1", "?ê¾¨ì”«??æ¹²ê³•ë’«2"] ?ë¨®ë’— []
}`;

  try {
    const response = await callGeminiAPI(prompt, "JSON ?ëº¤ë–‡?ì‡°ì¤ˆï§??ë¬ë–Ÿ?ì„ê½­??");

    let result;
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        result = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("JSON ?ëš¯ë–› ?ã…½ë™£");
      }
    } catch (e) {
      // JSON ?ëš¯ë–› ?ã…½ë™£ ???ë¿ë’ª?ëª„ë¿‰???ë¨®ë–’
      const passed = response.includes('passed": true') || response.includes('?ëº£ë–Ÿ') || response.includes('?â‘·êº½');
      result = { score: passed ? 80 : 50, passed, feedback: response, missing: [] };
    }

    mode6State.submitted = true;
    mode6State.isCorrect = result.passed;

    // å¯ƒê³Œë‚µ UI
    const bgColor = result.passed ? 'rgba(94, 230, 167, 0.1)' : 'rgba(255, 107, 107, 0.1)';
    const borderColor = result.passed ? 'var(--green)' : 'var(--red)';
    const icon = result.passed ? '?? : '??;
    const title = result.passed ? '?ëº£ë–Ÿ?ë‚…ë•²??' : '?ê¾©ì­… éºÂ€è­°ê¹Šë¹??;

    resultDiv.innerHTML = `
      <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 12px; padding: 20px;">
        <h3 style="color: ${result.passed ? 'var(--green)' : 'var(--red)'}; margin: 0 0 12px 0;">
          ${icon} ${title} (${result.score}??
        </h3>
        <div style="color: var(--text); line-height: 1.7; white-space: pre-line;">${escapeHtml(result.feedback)}</div>
        ${result.missing && result.missing.length > 0 ? `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid ${borderColor};">
            <strong style="color: var(--yellow);">?ë±¥ ?ê¾¨ì”«??æ¹²ê³•ë’«:</strong>
            <ul style="margin: 8px 0 0 0; padding-left: 20px;">
              ${result.missing.map(m => `<li>${escapeHtml(m)}</li>`).join('')}
            </ul>
          </div>
        ` : ''}
      </div>
    `;

    // ?ë¨¯ë‹” ?ë‚…ëœ²?ëŒ„ë“ƒ
    sessionScore.textContent = `${result.score} / 100`;

    // ?â‘£ë‚µ??    if (result.passed) {
      SoundEffects.play('correct');
      LearningStats.recordAnswer(true);
    } else {
      SoundEffects.play('wrong');
      LearningStats.recordAnswer(false);
    }

  } catch (err) {
    resultDiv.innerHTML = `<div class="mc-wrong" style="padding: 20px;">??ï§¢ê¾©ì  ?ã…»ìªŸ: ${err.message}</div>`;
  }
}

/**
 * ï§â‘¤ë±¶ 6 ç¥ë‡ë¦°?? */
function resetMode6() {
  const codeInput = document.getElementById('mode6-code-input');
  const resultDiv = document.getElementById('mode6-result');

  if (codeInput) codeInput.value = '';
  if (resultDiv) resultDiv.innerHTML = '';

  mode6State.userCode = '';
  mode6State.submitted = false;
  mode6State.isCorrect = null;
}

/**
 * ï§â‘¤ë±¶ 6 ?ëš°ë“ƒ è¹‚ë‹¿ë¦°
 */
async function showMode6Hint() {
  const resultDiv = document.getElementById('mode6-result');
  resultDiv.innerHTML = `<div class="definition-loading">?ë®• ?ëš°ë“ƒ ?ì•¹ê½¦ ä»¥?..</div>`;

  const prompt = `è‡¾ëª„ì £: ${mode6State.problem}

??è‡¾ëª„ì £ç‘œ??Â€æ¹²??ê¾ªë¸³ ?ë“­ë–– ?ëš°ë“ƒç‘œ??ëš®ì ®äºŒì‡±ê½­??
1. ?ê¾©ë‹” importè‡¾?2. æ¹²ê³•ë‚¯ è‚„ë¶¾ë±¶ æ´ÑŠâ€œ (?ì„ê¶— è‚„ë¶¾ë±¶ ?ì„?)
3. äºŒì‡±ì“½????
?ëº£ë–Ÿ è‚„ë¶¾ë±¶ç‘œ?ï§ê³¸ì ’ äºŒì‡±? ï§ë¨­í€¬, ?ëš°ë“ƒï§?äºŒì‡±ê½­??`;

  try {
    const response = await callGeminiAPI(prompt, "?ëš°ë“ƒï§??ì’“ë‚¬?ì„ê½­?? ?ëº£ë–Ÿ è‚„ë¶¾ë±¶??äºŒì‡±? ï§ë‰ê½­??");
    resultDiv.innerHTML = `
      <div style="background: rgba(247, 215, 116, 0.1); border: 1px solid rgba(247, 215, 116, 0.3); border-radius: 12px; padding: 20px;">
        <h3 style="color: var(--yellow); margin: 0 0 12px 0;">?ë®• ?ëš°ë“ƒ</h3>
        <div style="color: var(--text); line-height: 1.7; white-space: pre-line;">${escapeHtml(response)}</div>
      </div>
    `;
  } catch (err) {
    resultDiv.innerHTML = `<div class="mc-wrong">?ëš°ë“ƒ ?ì•¹ê½¦ ?ã…½ë™£: ${err.message}</div>`;
  }
}

// ============================================================================
// ï§â‘¤ë±¶ 1: C# OOP é®ë‰ë­ ï§¢ê¾©ìŠ¦æ¹²?// ----------------------------------------------------------------------------
// CSharp_è‚„ë¶¾ë±¶è‡¾ëª„ì £.txtç‘œ??ëš¯ë–›?ì„ë¿¬ è‡¾ëª„ì £ç‘œ?æ¿¡ì’•ë±¶?ì„í€¬, é®ë‰ë­ ç§»ëŒ€ë±¶ UIæ¿¡??ì’–ë–†
// ============================================================================

// ï§â‘¤ë±¶ 1 ?ê³¹ê¹­ æ„¿Â€ç”±?let mode1State = {
  questions: [],    // ?ëš¯ë–›??è‡¾ëª„ì £??{ topic, description, code, blanks: [{num, answer}] }
  userAnswers: {},  // ?ÑŠìŠœ???ë“¬?
  difficulty: 'normal' // easy, normal, hard
};

/**
 * CSharp_è‚„ë¶¾ë±¶è‡¾ëª„ì £.txt ?ëš¯ì”ª???ëš¯ë–›?ì„ë¿¬ è‡¾ëª„ì £ è«›ê³—ë¿´ è«›ì„‘ì†š
 */
function parseCSharpQuestions(text) {
  console.log('[Mode1] ?ëš¯ë–› ?ì’–ì˜‰, ?ë¿ë’ª??æ¹²ëª„ì” :', text.length);
  const questions = [];

  // ===== è‡¾ëª„ì £ N: æ¿¡?éºê¾¨â”
  const blocks = text.split(/={5,}\s*è‡¾ëª„ì £\s*\d+\s*:\s*/);
  console.log('[Mode1] éºê¾¨â”??é‡‰ë¶¾ì¤‰ ??', blocks.length);

  blocks.forEach((block, idx) => {
    if (idx === 0) return; // ï§£?é‡‰ë¶¾ì¤‰?Â€ ?ëš¯ì”ª ?ã…»ëœ‘

    const lines = block.trim().split('\n');
    let topic = '';
    let description = '';
    let code = '';
    let answers = {};
    let inAnswerKey = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // ï§£?ä»¥ê¾©ë¿‰???ì’•ã‰ ç•°ë¶¿í…§ (===== æ¿¡??ì•¸êµ¹??ä»¥?
      if (i === 0 && line.includes('=====')) {
        topic = line.replace(/=+/g, '').trim();
        continue;
      }

      // // æ¿¡??ì’–ì˜‰?ì„ë’— ï§£?è¸°ë‰ã ä»¥?= ?ã…»ì±¸
      if (line.trim().startsWith('//') && !description && !inAnswerKey) {
        description = line.replace(/^\/\/\s*/, '').trim();
        continue;
      }

      // ?ëº£ë–Ÿ???ë±€ë€¡ ?ì’–ì˜‰
      if (line.includes('?ëº£ë–Ÿ??')) {
        inAnswerKey = true;
        continue;
      }

      // ?ëº£ë–Ÿ???ëš¯ë–›
      if (inAnswerKey) {
        const answerMatch = line.match(/^(\d+)=(.+)$/);
        if (answerMatch) {
          answers[answerMatch[1]] = answerMatch[2].trim();
        }
        continue;
      }

      // è‚„ë¶¾ë±¶ ?ì„ì­› (?ëº£ë–Ÿ???ì’–ì˜‰ ?ê¾§í‰´ï§Â€ ï§â‘¤ë±º ä»¥?
      code += line + '\n';
    }

    // é®ë‰ë­ åª›ì’–ë‹” ?ëº¤ì”¤
    const blankCount = (code.match(/_____/g) || []).length;
    const answerCount = Object.keys(answers).length;

    console.log(`[Mode1] è‡¾ëª„ì £ ${idx}: topic="${topic}", é®ë‰ë­=${blankCount}, ?ëº£ë–Ÿ=${answerCount}`);

    if (topic && code.trim() && blankCount > 0 && answerCount > 0) {
      // é®ë‰ë­ ?ëº£ë‚« ?ì•¹ê½¦
      const blanks = [];
      for (let num = 1; num <= Math.min(blankCount, answerCount); num++) {
        if (answers[num.toString()]) {
          blanks.push({
            num: num,
            answer: answers[num.toString()]
          });
        }
      }

      questions.push({
        id: idx,
        topic: topic,
        description: description || topic,
        code: code.trim(),
        blanks: blanks,
        answers: answers
      });
    }
  });

  console.log('[Mode1] ?ëš¯ë–› ?ê¾¨ì¦º, è‡¾ëª„ì £ ??', questions.length);
  return questions;
}

/**
 * ï§â‘¤ë±¶ 1 ?ëš®ëœ‘ï§??â‘¥ë‹”
 * - CSharp_è‚„ë¶¾ë±¶è‡¾ëª„ì £.txt ?ëš¯ì”ª??æ¿¡ì’•ë±¶?ì„í€¬ ?ëš¯ë–›
 * - blank-card ?ã…½???UIæ¿¡??ì’–ë–†
 * - æ´Ñ‰Ğ¦ åª›ëº¤â€œ ?ê³¸ìŠœ
 */
async function renderMode1OOPBlanks() {
  const codeArea = document.getElementById('code-area');
  codeArea.innerHTML = `<div class="definition-loading">?ë±› C# OOP è‡¾ëª„ì £ç‘œ?éºëˆìœ­?ã…»ë’— ä»¥?..</div>`;

  // ?ì’•ã‰ ?ë‚…ëœ²?ëŒ„ë“ƒ
  sessionTitle.textContent = "C# OOP é®ë‰ë­ ï§¢ê¾©ìŠ¦æ¹²?;
  sessionMode.textContent = "OOP é®ë‰ë­ ï§¢ê¾©ìŠ¦æ¹²?;

  try {
    // ?ëš¯ì”ª æ¿¡ì’•ë±¶ (?ê³·? å¯ƒìˆì¤ˆæ¿¡?- GitHub Pages?Â€ æ¿¡ì’–ëº„ ?ì’•ì¾­ ï§â‘¤ëª¢ ?ëª…ì†š)
    const basePaths = ['data/', '../data/', './data/', '/data/'];
    const fileNames = ['3_OOP_è‚„ë¶¾ë±¶é®ë‰ë­.txt', 'CSharp_è‚„ë¶¾ë±¶è‡¾ëª„ì £.txt'];

    let text = "";
    let loaded = false;

    // ?Ñ‰ìœ­ å¯ƒìˆì¤ˆ?Â€ ?ëš¯ì”ªï§?è­°ê³ ë¹€ ?ì’•ë£„
    for (const basePath of basePaths) {
      if (loaded) break;
      for (const fileName of fileNames) {
        const url = basePath + fileName + '?t=' + Date.now();
        try {
          const resp = await fetch(url);
          if (resp.ok) {
            text = await resp.text();
            if (text.trim().length > 0) {
              console.log('[Mode1] ?ëš¯ì”ª æ¿¡ì’•ë±¶ ?ê¹ƒë‚¬:', url);
              loaded = true;
              break;
            }
          }
        } catch (e) {
          console.log('[Mode1] ?ì’•ë£„:', url, '?ã…½ë™£');
        }
      }
    }

    if (!loaded || !text.trim()) {
      throw new Error('?ëš¯ì”ª??ï§¡ì– ì“£ ???ë†ë’¿?ëˆë–');
    }

    // è‡¾ëª„ì £ ?ëš¯ë–›
    const allQuestions = parseCSharpQuestions(text);

    if (allQuestions.length === 0) {
      throw new Error('è‡¾ëª„ì £ç‘œ??ëš¯ë–›?????ë†ë’¿?ëˆë–');
    }

    // ?ì’–ì” ?ê¾©ë¿‰ ?ê³•ì”ª è‡¾ëª„ì £ ?ì¢ê¹® (?ê¾©ì˜±???ê¾©ê»œ ?ÑŠìŠœ)
    mode1State.questions = allQuestions;
    mode1State.userAnswers = {};
    mode1State.submitted = false;

    // UI ?ëš®ëœ‘ï§?- blank-card ?ã…½???    let questionsHtml = '';
    let navHtml = '';
    let globalBlankIdx = 0;

    allQuestions.forEach((q, qIdx) => {
      const questionNum = qIdx + 1;

      // C# æ´Ñ‰Ğ¦ åª›ëº¤â€œ ??é®ë‰ë­???ë‚…ì ° ?ê¾¨ë±¶æ¿¡?è¹‚Â€??      let processedCode = highlightCSharpSyntax(q.code);
      let blankCounter = 1;
      processedCode = processedCode.replace(/_____/g, () => {
        const blank = q.blanks.find(b => b.num === blankCounter);
        const answer = blank ? blank.answer : '';
        const inputWidth = Math.max(answer.length * 10 + 20, 80);
        globalBlankIdx++;
        const blankId = `mode1-${questionNum}-${blankCounter}`;

        navHtml += `<span class="blank-pill pending" id="nav-${blankId}" data-q="${questionNum}" data-blank="${blankCounter}" onclick="document.getElementById('input-${blankId}').focus()">${globalBlankIdx}</span>`;

        const result = `<input type="text" id="input-${blankId}" class="blank-card-input mode1-input" data-q="${questionNum}" data-blank="${blankCounter}" data-answer="${escapeHtml(answer)}" placeholder="[${globalBlankIdx}]" style="width: ${inputWidth}px; padding: 6px 10px; border-radius: 6px; border: 2px solid #6fb3ff; background: rgba(111, 179, 255, 0.15); color: #e5e9f0; font-family: var(--font-code); font-size: 13px; transition: all 0.15s ease;">`;
        blankCounter++;
        return result;
      });

      questionsHtml += `
        <div class="blank-card" id="mode1-card-${questionNum}">
          <div class="blank-card-header">
            <span class="blank-card-num">Q${questionNum}</span>
            <span style="color: var(--accent-2); font-weight: 600;">${escapeHtml(q.topic)}</span>
          </div>
          <p style="color: var(--muted); margin: 0 0 12px 0; font-size: 13px;">${escapeHtml(q.description)}</p>
          <pre class="blank-card-code" style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 8px; overflow-x: auto; margin: 0; line-height: 1.6;">${processedCode}</pre>
          <div class="blank-card-result" id="result-mode1-${questionNum}"></div>
        </div>
      `;
    });

    codeArea.innerHTML = questionsHtml;

    // é®ë‰ë­ ï§â‘¸ì¤‰ ?ë‚…ëœ²?ëŒ„ë“ƒ
    const blankList = document.getElementById('blank-list');
    if (blankList) {
      blankList.innerHTML = navHtml;
    }

    // ?ëª„ë€¡ ç§»ëŒìŠ«???ë‚…ëœ²?ëŒ„ë“ƒ
    sessionCount.textContent = globalBlankIdx.toString();
    sessionScore.textContent = `0 / ${globalBlankIdx}`;

    // ?ëŒ€ê¹½??ç”±ÑŠë’ª???ã…¼ì ™
    setupMode1EventListeners();

  } catch (err) {
    codeArea.innerHTML = `<div class="mc-wrong" style="padding: 20px;">???ã…»ìªŸ: ${err.message}<br><br><button onclick="renderMode1OOPBlanks()" style="padding: 10px 20px; background: var(--accent-2); border: none; border-radius: 6px; cursor: pointer;">?ë´½ ?ã…¼ë–† ?ì’•ë£„</button></div>`;
  }
}

/**
 * C# è‚„ë¶¾ë±¶ æ´Ñ‰Ğ¦ åª›ëº¤â€œ
 */
function highlightCSharpSyntax(code) {
  // ?ã…¼ì™??åª›ëº¤â€œ
  const keywords = ['namespace', 'class', 'interface', 'public', 'private', 'protected', 'static', 'void', 'int', 'string', 'double', 'bool', 'new', 'return', 'if', 'else', 'for', 'foreach', 'while', 'try', 'catch', 'finally', 'throw', 'using', 'lock', 'object', 'in'];

  let result = code;

  // è‡¾ëª„ì˜„??åª›ëº¤â€œ (ç™’ì‡±? ï§£ì„â”)
  result = result.replace(/"([^"\\]|\\.)*"/g, '<span style="color: #ce9178;">"$&"</span>');
  result = result.replace(/<span style="color: #ce9178;">"("([^"\\]|\\.)*")"/g, '<span style="color: #ce9178;">$1');

  // äºŒì‡±ê½ åª›ëº¤â€œ
  result = result.replace(/(\/\/[^\n]*)/g, '<span style="color: #6a9955;">$1</span>');
  result = result.replace(/(\/\*[\s\S]*?\*\/)/g, '<span style="color: #6a9955;">$1</span>');

  // ?ã…¼ì™??åª›ëº¤â€œ
  keywords.forEach(kw => {
    const regex = new RegExp(`\\b(${kw})\\b`, 'g');
    result = result.replace(regex, '<span style="color: #569cd6;">$1</span>');
  });

  // ?Â€??åª›ëº¤â€œ
  const types = ['Console', 'Thread', 'Exception', 'DivideByZeroException', 'ArgumentException', 'ThreadStart'];
  types.forEach(type => {
    const regex = new RegExp(`\\b(${type})\\b`, 'g');
    result = result.replace(regex, '<span style="color: #4ec9b0;">$1</span>');
  });

  // ?ãƒ¬ì˜„ åª›ëº¤â€œ
  result = result.replace(/\b(\d+)\b/g, '<span style="color: #b5cea8;">$1</span>');

  return result;
}

/**
 * Mode 1 ?ëŒ€ê¹½??ç”±ÑŠë’ª???ã…¼ì ™
 */
function setupMode1EventListeners() {
  const inputs = document.querySelectorAll('.mode1-input');
  let lastEnterTime = {};

  inputs.forEach(input => {
    // Enter ??ï§£ì„â”: 1è¸°?= ï§£ëŒ„ê²•, 2è¸°?= ?ëº£ë–Ÿ ?ì’–ë–†
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const inputId = input.id;
        const now = Date.now();
        const lastTime = lastEnterTime[inputId] || 0;

        if (now - lastTime < 500) {
          // ?ë¶¾íˆ ?ë·€ê½£: ?ëº£ë–Ÿ ?ì’–ë–†
          checkMode1Single(input, true);
        } else {
          // ?ê¹ƒ? ?ë·€ê½£: ?ëº£ë–Ÿ/?ã…»ë–Ÿï§?ï§£ëŒ„ê²•
          checkMode1Single(input, false);
        }
        lastEnterTime[inputId] = now;

        // ?ã…¼ì“¬ é®ë‰ë­?ì‡°ì¤ˆ ?ëŒ€ë£
        const allInputs = Array.from(document.querySelectorAll('.mode1-input'));
        const currentIdx = allInputs.indexOf(input);
        if (currentIdx < allInputs.length - 1) {
          setTimeout(() => allInputs[currentIdx + 1].focus(), 100);
        }
      }
    });
  });
}

/**
 * Mode 1 åª›ì’•í€ é®ë‰ë­ ï§£ëŒ„ê²•
 */
function checkMode1Single(input, showAnswer = false) {
  const qNum = input.dataset.q;
  const blankNum = input.dataset.blank;
  const correctAnswer = input.dataset.answer;
  const userAnswer = input.value.trim();

  if (!userAnswer && !showAnswer) return;

  const navPill = document.getElementById(`nav-mode1-${qNum}-${blankNum}`);
  const normalize = s => s.replace(/\s+/g, '').toLowerCase();
  const isCorrect = normalize(userAnswer) === normalize(correctAnswer);

  input.classList.remove('correct', 'wrong', 'revealed');
  navPill?.classList.remove('pending', 'correct', 'wrong', 'revealed');

  if (showAnswer && !isCorrect) {
    // ?ëº£ë–Ÿ ?ì’–ë–†
    input.value = correctAnswer;
    input.classList.add('revealed');
    navPill?.classList.add('revealed');
    input.disabled = true;
    SoundEffects.play('wrong');
  } else if (isCorrect) {
    input.classList.add('correct');
    navPill?.classList.add('correct');
    SoundEffects.play('correct');
    LearningStats.recordAnswer(true);
  } else {
    input.classList.add('wrong');
    navPill?.classList.add('wrong');
    SoundEffects.play('wrong');
    LearningStats.recordAnswer(false);
  }

  updateMode1Score();
}

/**
 * Mode 1 ?ë¨¯ë‹” ?ë‚…ëœ²?ëŒ„ë“ƒ
 */
function updateMode1Score() {
  const inputs = document.querySelectorAll('.mode1-input');
  let correct = 0;
  let answered = 0;

  inputs.forEach(input => {
    if (input.classList.contains('correct') || input.classList.contains('revealed')) {
      answered++;
      if (input.classList.contains('correct')) correct++;
    } else if (input.classList.contains('wrong')) {
      answered++;
    }
  });

  sessionScore.textContent = `${correct} / ${inputs.length}`;
  const ratio = inputs.length ? (correct / inputs.length) * 100 : 0;
  sessionProgress.style.width = `${ratio}%`;
}

/**
 * Mode 1 ?ê¾©ê»œ ï§¢ê¾©ì 
 */
function checkMode1Answers() {
  document.querySelectorAll('.mode1-input').forEach(input => {
    if (!input.disabled) {
      checkMode1Single(input, true);
    }
  });
}

// End of Mode 1 implementation
